<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ykailh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-12T02:45:46.475Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ykailh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础之异常</title>
    <link href="http://yoursite.com/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/</id>
    <published>2020-08-07T11:28:14.000Z</published>
    <updated>2020-08-12T02:45:46.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>​    在一些情况下，由于<strong>非程序本身</strong>问题，例如:配置问题、错误输入、磁盘空间不足等等所导致的程序无法正常运行。</p><a id="more"></a><p><strong>例如：</strong></p><p>​    试图获取一个int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行后输入‘a’，由于没有正常的获取到int类型，程序发生异常。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E6%BC%94%E7%A4%BA.png" alt="异常演示"></p><p><strong>而下面两个情况也是程序无法正常运行，但是是程序本身的问题，不属于异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未定义num的情况下使用num，属于语法错误。不属于异常</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getsum(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getsum方法用于返回两个int类型的和</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为0，而不是预期是2，属于程序逻辑错误。不属于异常</span></span><br></pre></td></tr></table></figure><h1 id="Java如何处理异常"><a href="#Java如何处理异常" class="headerlink" title="Java如何处理异常"></a>Java如何处理异常</h1><p>​    当程序运行到某一处时发生了异常，程序会暂停运行查看产生异常的原因，并根据此原因生成一个<strong>“异常对象”</strong>然后向外<strong>“抛”</strong>，此时若此处有<strong>try…catch</strong>结构去<strong>“捕获”</strong>这个异常，则程序继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//try..catch语法下文有详解，这里可以理解为“捕获”异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>​    <strong>”捕获“</strong>异常后继续执行其他代码</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%BC%94%E7%A4%BA.png" alt="异常捕获演示"></p><p>若不能<strong>“捕获”</strong>这个异常则会继续<strong>“抛”</strong>给上一级调用者，直到被<strong>“捕获”</strong>，程序在被<strong>“捕获”</strong>处继续运行。最终上抛至JVM则程序<strong>”崩溃“</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testPao();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上级捕获到异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main中的其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>​    <img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E4%B8%8A%E6%8A%9B%E6%BC%94%E7%A4%BA.png" alt="异常上抛演示"></p><p>若不做<strong>“捕获”</strong>出来<strong>“上抛”</strong>至JVM，程序<strong>“崩溃”</strong></p><h1 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h1><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="异常的体系结构"></p><p>​    所有异常相关的类都有一个公共父类：java.lang.Throwable，Throwable分为两大派别Error和Exception。</p><p><strong>Error：</strong>是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>​    此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用<strong>不应该去处理此类错误</strong>。而是通过代码优化、硬件升级等方式解决。</p><p><strong>Exception：</strong>程序本身可以捕获并且可以处理的异常。</p><p>Exception又分为两大类，运行时异常（也叫不受检异常）和编译时异常（也叫受检异常或非运行时异常）。</p><p><strong>运行时异常：</strong>均为<strong>RuntimeException</strong>或它子类的对象。</p><p>​    表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常。在程序中可以选择捕获处理，但此错误一般是由程序逻辑错误引起的，所有<strong>不建议进行捕获处理。</strong></p><p><strong>编译时异常：</strong>Exception中<strong>除RuntimeException极其子类之外</strong>的异常。</p><p>​    编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</p><h1 id="捕获异常语法"><a href="#捕获异常语法" class="headerlink" title="捕获异常语法"></a>捕获异常语法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-执行特点"><a href="#1-执行特点" class="headerlink" title="1.执行特点"></a>1.执行特点</h2><ul><li><p>如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p></li><li><p>如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，        finally中会执行</p></li></ul><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><ul><li>catch 中的异常名通常都命名为e，<strong>非强制</strong>要求。</li><li>捕获异常时是从上到下执行，一旦<strong>前面的catch捕获到异常后面的catch就不会执行</strong>（类似于if…else if的选择分支结构），所以<strong>要将范围较大的异常类型的catch放到范围较小的catch底下</strong>（一般情况下范围较大的异常类型是范围较小的父类)，否则会导致范围较小的catch永远无法执行，此时编译器也会报错。</li></ul><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/catch%E9%A1%BA%E5%BA%8F.png" alt="catch顺序"></p><ul><li>try…catch…finally存在return时，在非finally的地方遇到return时，会先把此时需要return的值放到<strong>“操作数栈”</strong>中然后再去执行finally中的代码，然后最终执行return。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTryCatchFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            System.out.println(testTryReturn());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testTryReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行try，此时i = &quot;</span>+i);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//发生异常</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行catch，此时i = &quot;</span>+i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行finally，此时i = &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/return%E4%B8%8Etry.png" alt="return与try"></p><ul><li>若return存在于finally时，try和catch中的return没有机会执行。在实际开发中finally一般用于关闭资源等操作，不允许在finally中写return语句（编译器也会发出警告）。</li></ul><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><h2 id="1-throws"><a href="#1-throws" class="headerlink" title="1.throws"></a>1.throws</h2><p>​    用于告知调用者此方法可能抛出的异常</p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>子类重写父类方法时，throws的异常列表范围不能大于父类，原因是保证多态引用时能正确捕获异常</li></ul><h2 id="2-throw"><a href="#2-throw" class="headerlink" title="2.throw"></a>2.throw</h2><p>​    用于手动抛出异常</p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">&quot;异常信息&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>​    创建自定义异常的方式为创建一个类并继承Throwable或它的子类，在实际开发中通常是继承RuntimeException或Exception来自定义运行时异常或编译时异常。</p><p>​    <strong>建议在自定义异常时至少保留无参构造和异常信息message使用的有参构造</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCustomException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCustomException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    自定义异常只能手动通过throw抛出。</p><h1 id="关于异常的几个方法"><a href="#关于异常的几个方法" class="headerlink" title="关于异常的几个方法"></a>关于异常的几个方法</h1><p><strong>printStackTrace()：</strong></p><p>打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。</p><p><strong>e.getMessage()：</strong></p><p>只是获取异常的message信息</p><p><strong>关于异常信息的打印：</strong></p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h1&gt;&lt;p&gt;​    在一些情况下，由于&lt;strong&gt;非程序本身&lt;/strong&gt;问题，例如:配置问题、错误输入、磁盘空间不足等等所导致的程序无法正常运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之注解</title>
    <link href="http://yoursite.com/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-08-06T06:36:27.000Z</published>
    <updated>2020-08-11T02:53:46.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>​    <code>注解（Annotation）</code>可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为<code>@interface</code>，使用时的格式为<code>@注解名</code>。</p><a id="more"></a><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="1-基本注解"><a href="#1-基本注解" class="headerlink" title="1.基本注解"></a>1.基本注解</h2><p>​    基本注解是Java提供的最基础的几个注解，在<code>JDK1.5</code>版本加入注解时提供了三个基本注解，定义在<code>java.lang</code>包下</p><h3 id="1-1-Override"><a href="#1-1-Override" class="headerlink" title="1.1 @Override"></a>1.1 @Override</h3><p>​    使用在方法上，用于检查这个方法是否符合重写的要求，同时可以作为重写方法的标记，增加代码的可读性。若检查不符合重写要求则会在编译时报错。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%8A%A5%E9%94%99.png" alt="Override报错"></p><p>​    上图中若去掉@Override则正常识别为方法重载。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E5%8E%BB%E6%8E%89Override.png" alt="去掉Override"></p><p>​    正确重写方法时，报错消失，对于程序而言有无Override没有区别。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%AD%A3%E7%A1%AE%E9%87%8D%E5%86%99.png" alt="Override正确重写"></p><h3 id="1-2-SuppressWarnings"><a href="#1-2-SuppressWarnings" class="headerlink" title="1.2 @SuppressWarnings"></a>1.2 @SuppressWarnings</h3><p>​    可以使用在类，字段，方法，参数，构造方法，局部变量上。用于抑制编译器的警告信息。</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(“参数”)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;“参数1”，“参数2”.....&#125;)</span></span><br></pre></td></tr></table></figure><p>通过参数选择一个或多个抑制警告的种类。</p><table><thead><tr><th>参数</th><th align="left">抑制类型</th></tr></thead><tbody><tr><td>all</td><td align="left">抑制所有类型的警告</td></tr><tr><td>boxing</td><td align="left">抑制装箱、拆箱相关的警告</td></tr><tr><td>cast</td><td align="left">抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td align="left">抑制启用注释的警告</td></tr><tr><td>deprecation</td><td align="left">抑制过期方法警告</td></tr><tr><td>fallthrough</td><td align="left">抑制switch中缺失breaks的警告</td></tr><tr><td>finally</td><td align="left">抑制finally模块没有返回的警告</td></tr><tr><td>incomplete-switch</td><td align="left">忽略没有完整的switch语句</td></tr><tr><td>nls</td><td align="left">忽略非nls格式的字符</td></tr><tr><td>null</td><td align="left">忽略对null的操作</td></tr><tr><td>rawtypes</td><td align="left">使用generics时忽略没有指定相应的类型</td></tr><tr><td>serial</td><td align="left">忽略在serializable类中没有声明serialVersionUID变量</td></tr><tr><td>static-access</td><td align="left">抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td align="left">抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td align="left">抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td align="left">抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td align="left">抑制没被使用过的代码的警告</td></tr></tbody></table><p>使用示例：</p><p>​        定义变量a但未使用，编译器抛出警告。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="未使用SuppressWarnings"></p><p>使用SuppressWarnings后</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="使用SuppressWarnings"></p><h3 id="1-3-Deprecated"><a href="#1-3-Deprecated" class="headerlink" title="1.3 @Deprecated"></a>1.3 @Deprecated</h3><p>​    可以使用在类、方法、属性上，用于标记此方法已经废弃。由于java对修改关闭，对扩展开放的原则，已经废弃的方法一般不会直接删除，而是使用这个注解去标记它。</p><p>源代码中对已过期方法的标记：</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Deprecated.png" alt="源代码中的Deprecated"></p><p>自己使用@Deprecated：</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8Deprecated.png" alt="自己使用Deprecated"></p><h2 id="2-文档注解"><a href="#2-文档注解" class="headerlink" title="2.文档注解"></a>2.文档注解</h2><p>​    文档注解通常用于说明和记录程序的信息，以/** 开始，以 */结束。其中有一些用于标记信息内容的注解，建议养成编写文档注解的习惯，后续作为javadoc生成API的内容。</p><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">@author</td><td align="left">标识一个类的作者</td></tr><tr><td align="left">@deprecated</td><td align="left">指名一个过期的类或成员</td></tr><tr><td align="left">@exception</td><td align="left">标志一个类抛出的异常</td></tr><tr><td align="left">@param</td><td align="left">说明一个方法的参数</td></tr><tr><td align="left">@return</td><td align="left">说明返回值类型</td></tr><tr><td align="left">@see</td><td align="left">指定一个到另一个主题的链接</td></tr><tr><td align="left">@serial</td><td align="left">说明一个序列化属性</td></tr><tr><td align="left">@serialData</td><td align="left">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td></tr><tr><td align="left">@serialField</td><td align="left">说明一个ObjectStreamField组件</td></tr><tr><td align="left">@since</td><td align="left">标记当引入一个特定的变化时</td></tr><tr><td align="left">@throws</td><td align="left">和 @exception标签一样</td></tr><tr><td align="left">@version</td><td align="left">指定类的版本</td></tr></tbody></table><p>可以参考源码中的文档注解</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E8%A7%A3.png" alt="源码中的文档注解"></p><p><strong>格式规范：</strong></p><p>@param 形参名 形参数据类型 解释。（每个形参单独写一个@param）</p><p>@return 返回值类型 解释。（若为void则省略）</p><p>@throws 异常类型名 解释（每个可能抛出的异常单独写一个@throws，没有则省略）</p><p><strong>文档注解与代码请时刻保持一致！</strong></p><h2 id="3-JUnit"><a href="#3-JUnit" class="headerlink" title="3.JUnit"></a>3.JUnit</h2><p>​    JUnit是一个回归测试框架，常用于编写单元测试，现在多数开发环境中都集成了JUnit。使用Eclipse做一个简单的说明。</p><h3 id="3-1-使用JUnit"><a href="#3-1-使用JUnit" class="headerlink" title="3.1 使用JUnit"></a>3.1 使用JUnit</h3><p>​    右键项目选择 Build Part → Add Library</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit1.png" alt="使用JUnit1"></p><p>​    选择JUnit 然后完成（下一步可以选择JUnit的版本和路径）</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit2.png" alt="使用JUnit2"></p><p>​    添加成功</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit3.png" alt="使用JUnit3"></p><h3 id="3-2-JUnit中的注解"><a href="#3-2-JUnit中的注解" class="headerlink" title="3.2 JUnit中的注解"></a>3.2 JUnit中的注解</h3><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（5）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p><strong>执行顺序测试：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUni%E6%B5%81%E7%A8%8B.png" alt="JUni流程"></p><p><strong>执行结果：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%9C.png" alt="JUnit流程结果"></p><p><strong>执行流程图：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="JUnit流程图"></p><h3 id="3-3Junit的技巧"><a href="#3-3Junit的技巧" class="headerlink" title="3.3Junit的技巧"></a>3.3Junit的技巧</h3><p>​    由于@Test等注解都要求方法需要为public、无返回值且无形参。若需要测试的方法不符合这个条件，可以再本类中创建一个符合条件的方法去调用需要测试的方法。</p><p>​    <strong>以@Test为例：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%8A%80%E5%B7%A7.png" alt="JUnit技巧"></p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>​    上面介绍的注解中，我们实际涉及的只有注解的使用部分，除了使用已经定义好的注解外，我们还可以像定义类和接口那样自己定义注解。</p><h2 id="1-注解的声明"><a href="#1-注解的声明" class="headerlink" title="1.注解的声明"></a>1.注解的声明</h2><p>​        <strong>注解的声明的格式如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    注解类型元素</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注解的关键字为<code>@interface</code>,所有的注解自动继承<strong>java.lang.annotation.Annotation接口</strong> ，注解实现部分只能为<strong>注解类型元素</strong>。</p><h2 id="2元注解"><a href="#2元注解" class="headerlink" title="2元注解"></a>2元注解</h2><p>​     元注解是专门用于修饰注解的注解（注解注解的注解…..），在声明注解时使用。下面是一些常用的元注解</p><h3 id="2-1-Target"><a href="#2-1-Target" class="headerlink" title="2.1 @Target"></a>2.1 @Target</h3><p>​    用来限定此注解可以使用的位置，它使用一个枚举类型ElementType存放不同的常量对象指定不同权限，具体如下。</p><table><thead><tr><th>ElemntType.</th><th>使用位置</th></tr></thead><tbody><tr><td>TYPE</td><td>类，接口（包括注解类型）或枚举的声明</td></tr><tr><td>FIELD</td><td>属性的声明</td></tr><tr><td>METHOD</td><td>方法的声明</td></tr><tr><td>PARAMETER</td><td>方法形式参数声明</td></tr><tr><td>CONSTRUCTOR</td><td>构造方法的声明</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量声明</td></tr><tr><td>ANNOTATION_TYPE</td><td>注解类型声明</td></tr><tr><td>PACKAGE</td><td>包的声明</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Retention"><a href="#2-2-Retention" class="headerlink" title="2.2 @Retention"></a>2.2 @Retention</h3><p>​    用来标记此注解的声明周期，它使用一个枚举类型RetentionPolicy存放不同的常量对象指定不同权限，具体如下。</p><table><thead><tr><th>RetentionPolicy.</th><th>生命周期</th></tr></thead><tbody><tr><td>SOURCE</td><td>编译前</td></tr><tr><td>CLASS</td><td>运行前</td></tr><tr><td>RUNTIME</td><td>运行时</td></tr></tbody></table><p><strong>不同生命周期的效果：</strong></p><ul><li><p>编译前（RetentionPolicy.SOURCE），只存在于.Java文件当中，编译时会被编译器忽略，从而导致此注解不会存在于.class文件当中。实际效果与注释一致。</p></li><li><p>运行前（RetentionPolicy.CLASS），可以编译到.class文件当中，故编译器编译时可以根据注解信息做出相应操作，但在运行时会被JVM所忽略。</p></li><li><p>运行时（RetentionPolicy.RUNTIME），可以在运行时通过反射得到注解信息从而进行相应的判断和操作，是自定义注解所使用最多的权限。</p><p><strong><em>若自定义注解未指定@Retention则默认为RetentionPolicy.CLASS</em></strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Documented"><a href="#2-3-Documented" class="headerlink" title="2.3 @Documented"></a>2.3 @Documented</h3><p>​    用来标记此注解的是否能被JavaDoc生成到API当中。</p><p><strong>示例：</strong></p><p>声明一个带有@Documented的CherryAnnotation注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个不带有@Documented的CherryAnnotation2注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类，同时使用上面两个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CherryAnnotation</span></span><br><span class="line"><span class="meta">@CherryAnnotation2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDocumented</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javadoc导出，结果类中只显示了CherryAnnotation</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Documented%E7%A4%BA%E4%BE%8B.png" alt="Documented示例"></p><h3 id="2-4-Inherited"><a href="#2-4-Inherited" class="headerlink" title="2.4 @Inherited"></a>2.4 @Inherited</h3><p>​    用来标记此注解的是否能被子类继承。</p><p><strong>验证：</strong></p><p>在1.2.2CherryAnnotation注解基础上增加@Inherited</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation是可以被使用者的子类继承的</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造一下测试类,这里涉及到反射的知识，简单来说就是尝试获取子类中的CherryAnnotation（简单使用，代码不规范。不理解的可以先跳过，等到泛型和反射的知识就能理解了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@CherryAnnotation</span><br><span class="line">public class TestDocumented &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class cla &#x3D; TestDocumentedSon.class;</span><br><span class="line">        CherryAnnotation ca &#x3D;(CherryAnnotation)cla.getAnnotation(CherryAnnotation.class);</span><br><span class="line">        System.out.println(ca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestDocumentedSon extends TestDocumented &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码运行结果：</strong></p><p>成功获取到CherryAnnotation，说明子类继承了父类的@CherryAnnotation</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8Inherited.png" alt="使用Inherited"></p><p><strong>若没有使用@Inherited则不会被使用者的子类所继承，运行结果为null</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8Inherited.png" alt="未使用Inherited"></p><h2 id="3-注解类型元素"><a href="#3-注解类型元素" class="headerlink" title="3.注解类型元素"></a>3.注解类型元素</h2><p>​    注解元素类型是注解特有的一种语法，作用是供读取阶段根据元素的值进行不同操作。由于格式与抽象方法的定义一致，所以有人把注解类型元素叫做注解的抽象方法。又由于调用时需要类似赋值的操作，所以也有的叫做注解的变量/参数。</p><h3 id="3-1-注解类型元素的格式"><a href="#3-1-注解类型元素的格式" class="headerlink" title="3.1 注解类型元素的格式"></a>3.1 注解类型元素的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@元注解</span></span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    修饰符 元素类型 元素名();<span class="comment">//与抽象方法的格式一致</span></span><br><span class="line">        <span class="comment">//可以定义多个注解类型元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有几点需要注意：</strong></p><ul><li>修饰符必须为<strong>public</strong>，若省略则<strong>默认为public</strong>。</li><li>元素的类型只能是 <strong>基本数据类型</strong>、<strong>String</strong>、<strong>Class</strong>、<strong>枚举类型</strong>、<strong>注解类型</strong>（体现了注解的嵌套效果）以及<strong>上述类型的一位数组。</strong></li><li>不能在括号中定义任何参数，仅仅只是一个特殊的语法；</li></ul><h3 id="3-2-传入方式"><a href="#3-2-传入方式" class="headerlink" title="3.2 传入方式"></a>3.2 传入方式</h3><p>​    若定义了注解类型元素，则需要在使用这个注解时传入相应的值,格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@注解名(元素名1 = 传入的值,元素名2 = 传入的值)</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=1)</span><span class="comment">//使用3.1中的CherryAnnotation</span></span><br></pre></td></tr></table></figure><p><strong>有几点需要注意：</strong></p><ul><li>若注解中只定义了一个元素，可以将其命名为<strong>value</strong>，在使用注解时可以省略**元素名 =**，例如元注解中的@Target、@Retention。</li><li>如果没有默认值，使用注解时必须给该类型元素赋值</li><li>默认值的定义方法为在定义元素的后面加上<code>default</code>和（空格）默认值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改造一下CherryAnnotation</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span><span class="keyword">default</span> 1</span>;<span class="comment">//将元素a的默认值设为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;)</span><span class="comment">//使用时不传入a值则默认为1</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=2)</span><span class="comment">//若有传入值则为传入值。</span></span><br></pre></td></tr></table></figure><h2 id="4注解的读取"><a href="#4注解的读取" class="headerlink" title="4注解的读取"></a>4注解的读取</h2><p><strong>由于涉及反射内容，整理完Java基础之反射后再更新</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;注解（Annotation）&lt;/code&gt;可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为&lt;code&gt;@interface&lt;/code&gt;，使用时的格式为&lt;code&gt;@注解名&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>markdown常用语法</title>
    <link href="http://yoursite.com/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-05T08:26:21.000Z</published>
    <updated>2020-08-07T09:44:21.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h1><p>​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。</p><a id="more"></a><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><h3 id="0-标题"><a href="#0-标题" class="headerlink" title="0.标题"></a>0.标题</h3><p>​    标题格式：<strong># + 空格 + 标题内容</strong>，几个’#就代表几级标题。</p><h3 id="1-字体"><a href="#1-字体" class="headerlink" title="1.字体"></a>1.字体</h3><p>​        字体格式：<strong>*文本内容* 或  _文本内容_</strong> ，一个符号为<em>斜体文本</em>，两个符号为<strong>粗体文本</strong>，三个符号为**<em>粗斜体文本**</em>。</p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">*斜体文本* 或  _斜体文本_</td><td align="center"><em>斜体文本</em></td></tr><tr><td align="center">**粗体文本** 或 __粗体文本__</td><td align="center"><strong>粗体文本</strong></td></tr><tr><td align="center">***粗斜体文本*** 或 ___粗斜体文本___</td><td align="center"><strong><em>粗斜体文本</em></strong></td></tr></tbody></table><h3 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2.删除线"></a>2.删除线</h3><p>​        删除线格式：<strong>~~删除线文本~~</strong></p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">普通文本</td><td align="center">普通文本</td></tr><tr><td align="center">~~删除线文本~~</td><td align="center"><del>删除线文本</del></td></tr></tbody></table><h3 id="3-下划线"><a href="#3-下划线" class="headerlink" title="3.下划线"></a>3.下划线</h3><p>​        下划线格式：<strong>&lt;u&gt;带下划线的文本&lt;/u&gt;</strong></p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">普通文本</td><td align="center">普通文本</td></tr><tr><td align="center">&lt;u&gt;带下划线的文本&lt;/u&gt;</td><td align="center"><u>带下划线的文本</u></td></tr></tbody></table><h3 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h3><p>​    <strong>使用脚注</strong>：文本内容[^脚注名称]，<strong>解释脚注：</strong>[^脚注名称]:脚注内容。</p><p>​    <strong>效果</strong>：文本内容<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^脚注</a></p><h3 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h3><p>​    使用三个或以上 * 或 - 来使用下划线，可以在符号中加空格（可能会在编写软件中识别为其他符号，<strong>不建议使用</strong>），且本行中不可有其他内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">几种分割线示意：</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>分割线效果：</p><hr><p><strong>错误示范</strong>：***其他内容（未出现分割线效果）</p><h2 id="列表与区块"><a href="#列表与区块" class="headerlink" title="列表与区块"></a>列表与区块</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    无序列表格式：<strong>* 或 + 或 - 加上一个空格后面再加上内容</strong>，三个符号效果相同。</p><p><strong>输入</strong>：</p><p>​    * 无序第一列</p><p>​    + 无序第二列</p><p>​    -  无序第三列</p><p><strong>效果</strong>：</p><pre><code>    * 无序第一列</code></pre><ul><li>无序第二列</li></ul><ul><li>无序第三列</li></ul><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​    有序列表格式：<strong>数字+ . + 空格 + 内容</strong>，即将无序列表的符号替换为数字加点的格式（例如1.）。</p><p><strong>输入</strong>：</p><p>​    1. 有序第一列</p><p>​    2. 有序第二列</p><p>​    3. 有序第三列</p><p><strong>效果</strong>:</p><ol><li>有序第一列</li><li>有序第二列</li><li>有序第三列</li></ol><h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​    在语法中为在<strong>子列表前添加四个空格</strong>，不过一般都在编写软件上编写<strong>更推荐使用TAB（缩进）与SHIFT+TAB（反缩进）</strong></p><p>​    <strong>输入</strong>：</p><p>​    1. 第一项：</p><p>​        * 第一项嵌套的第一个元素</p><p>​        * 第一项嵌套的第二个元素</p><p>​    2. 第二项：</p><p>​        * 第二项嵌套的第一个元素</p><p>​        * 第二项嵌套的第二个元素</p><p><strong>效果</strong>:</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<pre><code>* 第二项嵌套的第一个元素   * 第二项嵌套的第二个元素</code></pre></li></ol><h3 id="4-区块"><a href="#4-区块" class="headerlink" title="4.区块"></a>4.区块</h3><p>​    区块格式：<strong>在每行前加上 &gt; 然后紧跟一个空格。</strong></p><p><strong>输入：</strong></p><p>&gt; 区块引用第一行</p><p>&gt; 区块引用第二行</p><p><strong>效果：</strong></p><blockquote><p>区块引用第一行</p><p>区块引用第二行</p></blockquote><h3 id="5-区块嵌套"><a href="#5-区块嵌套" class="headerlink" title="5.区块嵌套"></a>5.区块嵌套</h3><p>​    区块嵌套格式：<strong>每有一个 &gt; 号就表示一层嵌套</strong></p><p><strong>输入：</strong></p><p>&gt; 最外层</p><p>&gt;&gt; 第一层嵌套</p><p>&gt;&gt;&gt; 第二层嵌套</p><p>**效果: **</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-代码片段"><a href="#1-代码片段" class="headerlink" title="1.代码片段"></a>1.代码片段</h3><p>​    代码片段格式：**` 代码内容 ` **(反引号)</p><p>​    <strong>输入：</strong> ` int a ;`         <strong>效果：</strong> <code>int a;</code></p><h3 id="2-代码区块"><a href="#2-代码区块" class="headerlink" title="2.代码区块"></a>2.代码区块</h3><p>​    格式：用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><p><strong>输入：</strong></p><p>​    ``` java</p><p>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(“Hello World”);<br>    }<br>}</p><p>​    ```</p><p><strong>效果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="1-直接显示链接"><a href="#1-直接显示链接" class="headerlink" title="1.直接显示链接"></a>1.直接显示链接</h3><p>​    语法格式: <strong>&lt; 链接 &gt; **    **效果:</strong> <a href="https://www.baidu.com/">https://www.baidu.com/</a></p><h3 id="2-用名称替代链接"><a href="#2-用名称替代链接" class="headerlink" title="2.用名称替代链接"></a>2.用名称替代链接</h3><p>​    语法格式：**[链接名称](链接地址)  **效果：这是我的<a href="https://ykailh.github.io/">博客</a></p><h3 id="3-用名称和变量替代链接"><a href="#3-用名称和变量替代链接" class="headerlink" title="3.用名称和变量替代链接"></a>3.用名称和变量替代链接</h3><p>​    语法格式：<strong>[链接名称][变量名称]，[变量名称]</strong>: 链接。变量定义类似于脚注，效果与用名称替代类似，但方便多次使用。</p><p>效果：这是一个<a href="https://www.baidu.com/">百度链接</a>，再次使用<a href="https://www.baidu.com/">百度链接</a>。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    <strong>用 | 来分隔单元格，- 来分隔表头。</strong></p><p><strong>输入：</strong></p><p>| 表头 | 表头 |</p><p>|  —-  |  —-  |</p><p>| 单元格 | 单元格 |</p><p>| 单元格 | 单元格 |</p><p><strong>效果：</strong></p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>默认为左对齐</strong></p><hr><p>将分隔符替换为<strong>-: , :-  , :-:</strong> 分别表示右对齐，左对齐，居中对齐。</p><p><strong>输入：</strong></p><p>| 左对齐 | 右对齐 | 居中对齐 |</p><p>|  :—-  |  —-:  | :—-: |</p><p>| 单元格 | 单元格 | 单元格 |</p><p>| 单元格 | 单元格 | 单元格 |</p><p><strong>效果</strong>：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>​    图片插入格式：![图片名](图片相对路径/绝对路径/图片链接)；</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>​    编写md文件时建议使用专用的编辑器，一般都支持自动补全和实时预览，可以提高编写的效率。博主正在用的也是许多人推荐的Typora,也推荐给大家。<a href="https://www.typora.io/">Typora官网</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown常用语法&quot;&gt;&lt;a href=&quot;#markdown常用语法&quot; class=&quot;headerlink&quot; title=&quot;markdown常用语法&quot;&gt;&lt;/a&gt;markdown常用语法&lt;/h1&gt;&lt;p&gt;​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用软件" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="Typora" scheme="http://yoursite.com/tags/Typora/"/>
    
      <category term="常用软件" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
