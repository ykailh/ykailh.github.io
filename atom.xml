<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ykailh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-13T08:53:21.416Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ykailh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础之字符串</title>
    <link href="http://yoursite.com/2020/08/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/08/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-09T13:52:36.000Z</published>
    <updated>2020-08-13T08:53:21.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h1><p>​        <strong><em>以下说明及演示基于JDK1.8版本</em></strong></p><ol><li>字符串String类型本身是final声明的，字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象。</li><li>String对象内部是用数组进行保存的，在<strong>JDK1.9之前</strong>用的是字符数组<code>char[]</code>，<strong>JDK1.9之后</strong>使用的是字节数组<code>byte[]</code>。</li></ol><a id="more"></a><ol start="3"><li>String类中这个<code>values</code>数组,同时由<code>final</code>和<code>private</code>修饰，意味着这个数组<strong>不可变并且不能通过外部进行操作</strong>，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以<strong>保证了String对象的不可变</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.8中String类的部分源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用char数组进行存储。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.8中只有char数组与哈希值，其他版本可能有所不同。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>由于字符串对象设计为不可变，那么所以有<strong>字符串常量池</strong>来保存很多常量对象，<strong>JDK1.6以及之前</strong>，常量池设计在<strong>方法区</strong>当中。但由于字符串所占空间比较大，所以<strong>JDk1.7时</strong>将常量池移到了<strong>堆</strong>当中，<strong>JDk1.8</strong>后取消了<strong>方法区</strong>取而代之的是<strong>元空间</strong>，字符串常量池也在<strong>元空间</strong>当中。</li></ol><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><h2 id="1"><a href="#1" class="headerlink" title="1.=="></a>1.==</h2><p>​    <code>==</code>用来比较对象的地址值，因为字符串特殊的存储方式，导致地址比较情况比较多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>).intern();</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>​    <strong>内存示意图：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="字符串内存图"></p><h2 id="2-equals"><a href="#2-equals" class="headerlink" title="2.equals()"></a>2.equals()</h2><p>​    <strong>用于比较对象的内容是否相同</strong>，因为String类型重写equals，区分大小写只要两个字符串的字符内容相同，就会返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>查看一下String类中的<code>equals()</code>源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否指向同一个对象，如果是内容一定相同，返回ture</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//若传入参数不为String类则直接返回false</span></span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          <span class="keyword">int</span> n = value.length;</span><br><span class="line">          <span class="comment">//判断字符串长度是否相等，不相等则一定不相同，返回false</span></span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="keyword">char</span> v1[] = value;</span><br><span class="line">              <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">              <span class="comment">//逐个比较字符是否相等</span></span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>了避免空指针异常，若是与已知字符串做比较用已知字符串来调用方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;已知字符串&quot;</span>.equals（）</span><br></pre></td></tr></table></figure><h2 id="3-equalsIgnoreCase"><a href="#3-equalsIgnoreCase" class="headerlink" title="3.equalsIgnoreCase()"></a>3.equalsIgnoreCase()</h2><p>​    <strong>用于不区分大小写的比较字符串内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.equalsIgnoreCase(<span class="string">&quot;a&quot;</span>));<span class="comment">//ture</span></span><br></pre></td></tr></table></figure><h2 id="4-compareTo"><a href="#4-compareTo" class="headerlink" title="4.compareTo()"></a>4.compareTo()</h2><p>​    <strong>用于按照字符的Unicode编码值进行排序</strong>,String类型重写了<code>Comparable接口</code>的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.compareTo(<span class="string">&quot;a&quot;</span>));<span class="comment">//-32</span></span><br><span class="line">System.out.println(<span class="string">&quot;AB&quot;</span>.compareTo(<span class="string">&quot;A&quot;</span>));<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><strong>源码如下:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类中的compareTo方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;<span class="comment">//返回char的差值，说明按照Unicode编码值进行排序</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len1 - len2;<span class="comment">//若一方为另一方的子字符串，则判定为较小的一方</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-compareToIgnoreCase"><a href="#5-compareToIgnoreCase" class="headerlink" title="5.compareToIgnoreCase()"></a>5.compareToIgnoreCase()</h2><p>​    <strong>用于不区分大小的情况下按照字符的Unicode编码值进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.compareToIgnoreCase(<span class="string">&quot;a&quot;</span>));<span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;AB&quot;</span>.compareToIgnoreCase(<span class="string">&quot;Ab&quot;</span>));<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><h2 id="1-“-”连接符的实现"><a href="#1-“-”连接符的实现" class="headerlink" title="1.“+”连接符的实现"></a>1.“+”连接符的实现</h2><p>​    <strong>引入一段对API中String类的描述</strong></p><blockquote><p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 <code>StringBuilder</code>（或  <code>StringBuffer</code>）类及其 <code>append</code> 方法实现的。字符串转换是通过  <code>toString</code> 方法实现的，该方法由 <code>Object</code> 类定义，并可被 Java 中的所有类继承。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">String s3 = s1 + s2;<span class="comment">//第三行的代码等价于第四行</span></span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br></pre></td></tr></table></figure><h2 id="2-编译器对“-”的优化"><a href="#2-编译器对“-”的优化" class="headerlink" title="2.编译器对“+”的优化"></a>2.编译器对“+”的优化</h2><p>​    当**”+”两端均为编译期确定的字符串常量**时，编译器会进行相应的优化，直接将两个字符串常量拼接好，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">//编译器优化之后</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s1 =<span class="string">&quot;A&quot;</span> + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">String s2 =<span class="string">&quot;AB&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//ture</span></span><br></pre></td></tr></table></figure><p>​    除了常量字符串外，还有一种也情况是为编译期确定的字符串常量，就是有<code>final</code>修饰的<code>String变量</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;B&quot;</span>;</span><br><span class="line"><span class="comment">//此时s1，s2不是编译期间确定的字符串常量，依然通过StringBuilde的方式连接字符串</span></span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">System.out.println(s3 == <span class="string">&quot;AB&quot;</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">String s3 = s1 + s2;<span class="comment">//此时s1，s2在编译期间就确定为字符串常量</span></span><br><span class="line"><span class="comment">//等价于 String = “A” + “B”，String s2 =&quot;AB&quot;;</span></span><br><span class="line">System.out.println(s3 == <span class="string">&quot;AB&quot;</span>);<span class="comment">//ture</span></span><br></pre></td></tr></table></figure><p>​    但也不是只要<code>final</code>修饰的<code>String变量</code>就一定是常量。例如下面这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = getS1();</span><br><span class="line">    String s3 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == <span class="string">&quot;AB&quot;</span>);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getS1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;B&quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-手动优化"><a href="#3-手动优化" class="headerlink" title="3.手动优化"></a>3.手动优化</h2><p>​    由于每次拼接非确定字符串时都需要隐式创建一个<code>StringBuilder对象</code>，如果存在需要<strong>大量循环拼接</strong>的情况则会在堆中创建大量的<code>StringBuilder对象</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这种情况建议直接创建一个StringBuilder对象再使用append()方法手动拼接，最后再转为字符串，这样可以提高效率节省内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure><h1 id="可变字符序列"><a href="#可变字符序列" class="headerlink" title="可变字符序列"></a>可变字符序列</h1><p>​    除了不可变的<code>String类</code>，java中还提供了可变字符序列的两个类：<code>StringBuilder类</code>和<code>StringBuffer类</code>。除了是否可变外这三个类的主要差别在运算性能和线程安全性上。</p><h2 id="1-运算速度比较"><a href="#1-运算速度比较" class="headerlink" title="1.运算速度比较"></a>1.运算速度比较</h2><p>​    通常情况下：<code>StringBuilder</code> &gt;<code>StringBuffer</code>&gt;<code> String</code></p><p>​    <code>String</code>是<code>final类</code>不能被继承且为字符串<strong>常量</strong>，而<code>StringBuilder</code>和<code>StringBuffer</code>均为字符串<strong>变量</strong>。<code>String</code>对象一旦创建便<strong>不可更改</strong>，而后两者是<strong>可更改的</strong>，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个null，通过append方法向StringBuffer和StringBuilder中赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = str + <span class="string">&quot;de&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>​    上述代码先创建一个<code>String</code>对象str，并赋值abc给str，然后运行到第三行，JVM会再创建一个新的str对象，并将原有str的值和de加起来再赋值给新的str。而第一个创建的str对象被JVM的垃圾回收机制（GC）回收掉。所以str实际上并没有被更改，即<code>String</code>对象一旦创建就不可更改。所以Java中对<code>String</code>对象进行的操作实际上是一个<strong>不断创建并回收对象的过程</strong>，因此在运行速度上很慢。</p><p>​    而<code>StringBuilder</code>比<code>StringBuffer</code>更快的源于没有了线程锁的损耗。</p><h2 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h2><p>​    <code>StringBuffer</code>（线程安全的）</p><p>​    <code>StringBuffer</code>中大部分方法由<code>synchronized</code>关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是<strong>线程安全</strong>的。</p><p>​    <code>StringBuilder</code>（非线程安全）</p><p>​    该类在<code>JDK1.5</code>时新增提供一个与StringBuffer兼容的 API，但不能保证同步，所以在性能上较高。因此，在大多数情况下优先使用StringBuilder</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p><code>String</code>：适用于少量的字符串操作。</p><p><code>StringBuilder</code>：适用于单线程下在字符串缓冲区进行大量操作。</p><p><code>StringBuffer</code>：适用于多线程下在字符串缓冲区进行大量操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串的特点&quot;&gt;&lt;a href=&quot;#字符串的特点&quot; class=&quot;headerlink&quot; title=&quot;字符串的特点&quot;&gt;&lt;/a&gt;字符串的特点&lt;/h1&gt;&lt;p&gt;​        &lt;strong&gt;&lt;em&gt;以下说明及演示基于JDK1.8版本&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串String类型本身是final声明的，字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象。&lt;/li&gt;
&lt;li&gt;String对象内部是用数组进行保存的，在&lt;strong&gt;JDK1.9之前&lt;/strong&gt;用的是字符数组&lt;code&gt;char[]&lt;/code&gt;，&lt;strong&gt;JDK1.9之后&lt;/strong&gt;使用的是字节数组&lt;code&gt;byte[]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之包装类</title>
    <link href="http://yoursite.com/2020/08/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/08/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-08-08T07:48:54.000Z</published>
    <updated>2020-08-13T09:00:37.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h1><p>​    Java作为面向对象的编程语言在设计之初依然延续了C语言的8种基本数据类型，但在不断的更新中设计了很多针对对象的API和新的特性（例如泛型），不支持基本数据类型。为了解决这个问题，Java为每一个基本数据类型提供了包装类。</p><a id="more"></a><table><thead><tr><th>基本数据类型</th><th>包装类（java.lang.）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h1 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h1><p>​    装箱和拆箱实际上就是<strong>基本数据类型和它的包装类之间的转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);    <span class="comment">//基本数据类型转为包装类也叫做手动装箱</span></span><br><span class="line"><span class="keyword">int</span> num2 = num1.intValue();        <span class="comment">//包装类转换为基本数据类型，也叫做手动拆箱</span></span><br></pre></td></tr></table></figure><p>​    在J<strong>DK1.5</strong>之后为了方便使用等目的提供了<strong>自动装箱与自动拆箱</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类中的自动装箱拆箱机制</span></span><br><span class="line">Integer  num1 = <span class="number">1</span>;        <span class="comment">//自动装箱</span></span><br><span class="line"><span class="comment">//这行代码实际等同于    Integer  num1 = Integer.valueOf(1);</span></span><br><span class="line"><span class="comment">//这个于new Integer(1)有所区别 下文会详细说明</span></span><br><span class="line"><span class="keyword">int</span> num2 = num1;        <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>​    需要注意的是只在与<strong>对应的基本数据类型和包装类之间</strong>才能实现自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double d = <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure><h1 id="包装类对象的缓存问题"><a href="#包装类对象的缓存问题" class="headerlink" title="包装类对象的缓存问题"></a>包装类对象的缓存问题</h1><p>​    为了引出这个问题首先做以下测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>​    为什么改变了在包装类的值会影响结果，这就涉及到了包装类对象的缓存问题。对于对象而言，<code>==</code>所比较的是两个对象的地址值，上面的代码就说明了<strong>在一定的范围内相同值的包装类指向的是同一个对象</strong>。每个包装类的缓存范围如下：</p><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table><p>​    <strong>以Integer为例</strong>，上面也提到过自动装箱时是调用<code>Integer.valueOf()</code>方法来获取Integer对象的，查看这个方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">//若在某一个范围内直接返回一个cache数组中的Integer对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   <span class="comment">//若不在这个范围则创建一个Integer对象返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再找到<code>IntegerCache</code> 这是Integer的一个内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以发现在Integer类初始化时会创建一个叫cache的数组，里面存放的是low至high范围的Integer类常量，这就是上面提到的缓存对象。</p><p>这就解释了为什么在一定范围内使用<code>==</code>比较两个包装类对象会返回turn。</p><p>再做几个比较实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i.equals(j));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line">System.out.println(i.equals(j));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>​    new出来的对象在堆当中，不指向常量对象，这就是<strong>new与valueOf()的区别</strong>，<code>valueOf()</code>只在超出缓存范围时才会创建一个新的对象，所以在实际使用过程中建议直接使用<code>valueOf()</code>。</p><p>​    而与基本数据类型比较（包括计算）时会<strong>先拆箱</strong>再按照基本数据类型的规则比较，所以为了避免歧义，如果是判断值是否相等时建议同一使用<code>equals()</code>方法。</p><h1 id="API演示"><a href="#API演示" class="headerlink" title="API演示"></a>API演示</h1><p>​    由于包装类的存在，许多处理基本数据类型的方法都可以定义在包装类中。下面进行一些<strong>举例</strong>。</p><h2 id="1-把字符串转为基本数据类型"><a href="#1-把字符串转为基本数据类型" class="headerlink" title="1.把字符串转为基本数据类型"></a>1.把字符串转为基本数据类型</h2><p>​    <code>parsxxx()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> a = Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Double.parseDouble(<span class="string">&quot;1.2&quot;</span>));<span class="comment">//1.2</span></span><br></pre></td></tr></table></figure><h2 id="2-数据类型的最大最小值"><a href="#2-数据类型的最大最小值" class="headerlink" title="2.数据类型的最大最小值"></a>2.数据类型的最大最小值</h2><p>​    <code>MAX_VALUE</code>和<code>MIN_VALUE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">//2147483647</span></span><br></pre></td></tr></table></figure><h1 id="3-转进制"><a href="#3-转进制" class="headerlink" title="3.转进制"></a>3.转进制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i) <span class="comment">//转为2进制</span></span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i)  <span class="comment">//转为8进制</span></span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i)   <span class="comment">//转为16进制</span></span><br><span class="line"></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">15</span>));<span class="comment">//1111</span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">15</span>));<span class="comment">//17</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">15</span>));<span class="comment">//f</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是包装类&quot;&gt;&lt;a href=&quot;#什么是包装类&quot; class=&quot;headerlink&quot; title=&quot;什么是包装类&quot;&gt;&lt;/a&gt;什么是包装类&lt;/h1&gt;&lt;p&gt;​    Java作为面向对象的编程语言在设计之初依然延续了C语言的8种基本数据类型，但在不断的更新中设计了很多针对对象的API和新的特性（例如泛型），不支持基本数据类型。为了解决这个问题，Java为每一个基本数据类型提供了包装类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="包装类" scheme="http://yoursite.com/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之异常</title>
    <link href="http://yoursite.com/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/</id>
    <published>2020-08-07T11:28:14.000Z</published>
    <updated>2020-08-13T09:00:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>​    在一些情况下，由于<strong>非程序本身</strong>问题，例如:配置问题、错误输入、磁盘空间不足等等所导致的程序无法正常运行。</p><a id="more"></a><p><strong>例如：</strong></p><p>​    试图获取一个int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行后输入‘a’，由于没有正常的获取到int类型，程序发生异常。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E6%BC%94%E7%A4%BA.png" alt="异常演示"></p><p><strong>而下面两个情况也是程序无法正常运行，但是是程序本身的问题，不属于异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未定义num的情况下使用num，属于语法错误。不属于异常</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getsum(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getsum方法用于返回两个int类型的和</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为0，而不是预期是2，属于程序逻辑错误。不属于异常</span></span><br></pre></td></tr></table></figure><h1 id="Java如何处理异常"><a href="#Java如何处理异常" class="headerlink" title="Java如何处理异常"></a>Java如何处理异常</h1><p>​    当程序运行到某一处时发生了异常，程序会暂停运行查看产生异常的原因，并根据此原因生成一个<strong>“异常对象”</strong>然后向外<strong>“抛”</strong>，此时若此处有<strong>try…catch</strong>结构去<strong>“捕获”</strong>这个异常，则程序继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//try..catch语法下文有详解，这里可以理解为“捕获”异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>​    <strong>”捕获“</strong>异常后继续执行其他代码</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%BC%94%E7%A4%BA.png" alt="异常捕获演示"></p><p>若不能<strong>“捕获”</strong>这个异常则会继续<strong>“抛”</strong>给上一级调用者，直到被<strong>“捕获”</strong>，程序在被<strong>“捕获”</strong>处继续运行。最终上抛至JVM则程序<strong>”崩溃“</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testPao();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上级捕获到异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main中的其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>​    <img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E4%B8%8A%E6%8A%9B%E6%BC%94%E7%A4%BA.png" alt="异常上抛演示"></p><p>若不做<strong>“捕获”</strong>出来<strong>“上抛”</strong>至JVM，程序<strong>“崩溃”</strong></p><h1 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h1><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="异常的体系结构"></p><p>​    所有异常相关的类都有一个公共父类：java.lang.Throwable，Throwable分为两大派别Error和Exception。</p><p><strong>Error：</strong>是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>​    此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用<strong>不应该去处理此类错误</strong>。而是通过代码优化、硬件升级等方式解决。</p><p><strong>Exception：</strong>程序本身可以捕获并且可以处理的异常。</p><p>Exception又分为两大类，运行时异常（也叫不受检异常）和编译时异常（也叫受检异常或非运行时异常）。</p><p><strong>运行时异常：</strong>均为<strong>RuntimeException</strong>或它子类的对象。</p><p>​    表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常。在程序中可以选择捕获处理，但此错误一般是由程序逻辑错误引起的，所有<strong>不建议进行捕获处理。</strong></p><p><strong>编译时异常：</strong>Exception中<strong>除RuntimeException极其子类之外</strong>的异常。</p><p>​    编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</p><h1 id="捕获异常语法"><a href="#捕获异常语法" class="headerlink" title="捕获异常语法"></a>捕获异常语法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-执行特点"><a href="#1-执行特点" class="headerlink" title="1.执行特点"></a>1.执行特点</h2><ul><li><p>如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p></li><li><p>如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，        finally中会执行</p></li></ul><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><ul><li>catch 中的异常名通常都命名为e，<strong>非强制</strong>要求。</li><li>捕获异常时是从上到下执行，一旦<strong>前面的catch捕获到异常后面的catch就不会执行</strong>（类似于if…else if的选择分支结构），所以<strong>要将范围较大的异常类型的catch放到范围较小的catch底下</strong>（一般情况下范围较大的异常类型是范围较小的父类)，否则会导致范围较小的catch永远无法执行，此时编译器也会报错。</li></ul><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/catch%E9%A1%BA%E5%BA%8F.png" alt="catch顺序"></p><ul><li>try…catch…finally存在return时，在非finally的地方遇到return时，会先把此时需要return的值放到<strong>“操作数栈”</strong>中然后再去执行finally中的代码，然后最终执行return。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTryCatchFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            System.out.println(testTryReturn());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testTryReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行try，此时i = &quot;</span>+i);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//发生异常</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行catch，此时i = &quot;</span>+i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行finally，此时i = &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/return%E4%B8%8Etry.png" alt="return与try"></p><ul><li>若return存在于finally时，try和catch中的return没有机会执行。在实际开发中finally一般用于关闭资源等操作，不允许在finally中写return语句（编译器也会发出警告）。</li></ul><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><h2 id="1-throws"><a href="#1-throws" class="headerlink" title="1.throws"></a>1.throws</h2><p>​    用于告知调用者此方法可能抛出的异常</p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>子类重写父类方法时，throws的异常列表范围不能大于父类，原因是保证多态引用时能正确捕获异常</li></ul><h2 id="2-throw"><a href="#2-throw" class="headerlink" title="2.throw"></a>2.throw</h2><p>​    用于手动抛出异常</p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">&quot;异常信息&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>​    创建自定义异常的方式为创建一个类并继承Throwable或它的子类，在实际开发中通常是继承RuntimeException或Exception来自定义运行时异常或编译时异常。</p><p>​    <strong>建议在自定义异常时至少保留无参构造和异常信息message使用的有参构造</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCustomException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCustomException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    自定义异常只能手动通过throw抛出。</p><h1 id="关于异常的几个方法"><a href="#关于异常的几个方法" class="headerlink" title="关于异常的几个方法"></a>关于异常的几个方法</h1><p><strong>printStackTrace()：</strong></p><p>打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。</p><p><strong>e.getMessage()：</strong></p><p>只是获取异常的message信息</p><p><strong>关于异常信息的打印：</strong></p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h1&gt;&lt;p&gt;​    在一些情况下，由于&lt;strong&gt;非程序本身&lt;/strong&gt;问题，例如:配置问题、错误输入、磁盘空间不足等等所导致的程序无法正常运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之注解</title>
    <link href="http://yoursite.com/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-08-06T06:36:27.000Z</published>
    <updated>2020-08-11T02:53:46.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>​    <code>注解（Annotation）</code>可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为<code>@interface</code>，使用时的格式为<code>@注解名</code>。</p><a id="more"></a><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="1-基本注解"><a href="#1-基本注解" class="headerlink" title="1.基本注解"></a>1.基本注解</h2><p>​    基本注解是Java提供的最基础的几个注解，在<code>JDK1.5</code>版本加入注解时提供了三个基本注解，定义在<code>java.lang</code>包下</p><h3 id="1-1-Override"><a href="#1-1-Override" class="headerlink" title="1.1 @Override"></a>1.1 @Override</h3><p>​    使用在方法上，用于检查这个方法是否符合重写的要求，同时可以作为重写方法的标记，增加代码的可读性。若检查不符合重写要求则会在编译时报错。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%8A%A5%E9%94%99.png" alt="Override报错"></p><p>​    上图中若去掉@Override则正常识别为方法重载。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E5%8E%BB%E6%8E%89Override.png" alt="去掉Override"></p><p>​    正确重写方法时，报错消失，对于程序而言有无Override没有区别。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%AD%A3%E7%A1%AE%E9%87%8D%E5%86%99.png" alt="Override正确重写"></p><h3 id="1-2-SuppressWarnings"><a href="#1-2-SuppressWarnings" class="headerlink" title="1.2 @SuppressWarnings"></a>1.2 @SuppressWarnings</h3><p>​    可以使用在类，字段，方法，参数，构造方法，局部变量上。用于抑制编译器的警告信息。</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(“参数”)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;“参数1”，“参数2”.....&#125;)</span></span><br></pre></td></tr></table></figure><p>通过参数选择一个或多个抑制警告的种类。</p><table><thead><tr><th>参数</th><th align="left">抑制类型</th></tr></thead><tbody><tr><td>all</td><td align="left">抑制所有类型的警告</td></tr><tr><td>boxing</td><td align="left">抑制装箱、拆箱相关的警告</td></tr><tr><td>cast</td><td align="left">抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td align="left">抑制启用注释的警告</td></tr><tr><td>deprecation</td><td align="left">抑制过期方法警告</td></tr><tr><td>fallthrough</td><td align="left">抑制switch中缺失breaks的警告</td></tr><tr><td>finally</td><td align="left">抑制finally模块没有返回的警告</td></tr><tr><td>incomplete-switch</td><td align="left">忽略没有完整的switch语句</td></tr><tr><td>nls</td><td align="left">忽略非nls格式的字符</td></tr><tr><td>null</td><td align="left">忽略对null的操作</td></tr><tr><td>rawtypes</td><td align="left">使用generics时忽略没有指定相应的类型</td></tr><tr><td>serial</td><td align="left">忽略在serializable类中没有声明serialVersionUID变量</td></tr><tr><td>static-access</td><td align="left">抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td align="left">抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td align="left">抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td align="left">抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td align="left">抑制没被使用过的代码的警告</td></tr></tbody></table><p>使用示例：</p><p>​        定义变量a但未使用，编译器抛出警告。</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="未使用SuppressWarnings"></p><p>使用SuppressWarnings后</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="使用SuppressWarnings"></p><h3 id="1-3-Deprecated"><a href="#1-3-Deprecated" class="headerlink" title="1.3 @Deprecated"></a>1.3 @Deprecated</h3><p>​    可以使用在类、方法、属性上，用于标记此方法已经废弃。由于java对修改关闭，对扩展开放的原则，已经废弃的方法一般不会直接删除，而是使用这个注解去标记它。</p><p>源代码中对已过期方法的标记：</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Deprecated.png" alt="源代码中的Deprecated"></p><p>自己使用@Deprecated：</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8Deprecated.png" alt="自己使用Deprecated"></p><h2 id="2-文档注解"><a href="#2-文档注解" class="headerlink" title="2.文档注解"></a>2.文档注解</h2><p>​    文档注解通常用于说明和记录程序的信息，以/** 开始，以 */结束。其中有一些用于标记信息内容的注解，建议养成编写文档注解的习惯，后续作为javadoc生成API的内容。</p><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">@author</td><td align="left">标识一个类的作者</td></tr><tr><td align="left">@deprecated</td><td align="left">指名一个过期的类或成员</td></tr><tr><td align="left">@exception</td><td align="left">标志一个类抛出的异常</td></tr><tr><td align="left">@param</td><td align="left">说明一个方法的参数</td></tr><tr><td align="left">@return</td><td align="left">说明返回值类型</td></tr><tr><td align="left">@see</td><td align="left">指定一个到另一个主题的链接</td></tr><tr><td align="left">@serial</td><td align="left">说明一个序列化属性</td></tr><tr><td align="left">@serialData</td><td align="left">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td></tr><tr><td align="left">@serialField</td><td align="left">说明一个ObjectStreamField组件</td></tr><tr><td align="left">@since</td><td align="left">标记当引入一个特定的变化时</td></tr><tr><td align="left">@throws</td><td align="left">和 @exception标签一样</td></tr><tr><td align="left">@version</td><td align="left">指定类的版本</td></tr></tbody></table><p>可以参考源码中的文档注解</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E8%A7%A3.png" alt="源码中的文档注解"></p><p><strong>格式规范：</strong></p><p>@param 形参名 形参数据类型 解释。（每个形参单独写一个@param）</p><p>@return 返回值类型 解释。（若为void则省略）</p><p>@throws 异常类型名 解释（每个可能抛出的异常单独写一个@throws，没有则省略）</p><p><strong>文档注解与代码请时刻保持一致！</strong></p><h2 id="3-JUnit"><a href="#3-JUnit" class="headerlink" title="3.JUnit"></a>3.JUnit</h2><p>​    JUnit是一个回归测试框架，常用于编写单元测试，现在多数开发环境中都集成了JUnit。使用Eclipse做一个简单的说明。</p><h3 id="3-1-使用JUnit"><a href="#3-1-使用JUnit" class="headerlink" title="3.1 使用JUnit"></a>3.1 使用JUnit</h3><p>​    右键项目选择 Build Part → Add Library</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit1.png" alt="使用JUnit1"></p><p>​    选择JUnit 然后完成（下一步可以选择JUnit的版本和路径）</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit2.png" alt="使用JUnit2"></p><p>​    添加成功</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit3.png" alt="使用JUnit3"></p><h3 id="3-2-JUnit中的注解"><a href="#3-2-JUnit中的注解" class="headerlink" title="3.2 JUnit中的注解"></a>3.2 JUnit中的注解</h3><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（5）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p><strong>执行顺序测试：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUni%E6%B5%81%E7%A8%8B.png" alt="JUni流程"></p><p><strong>执行结果：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%9C.png" alt="JUnit流程结果"></p><p><strong>执行流程图：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="JUnit流程图"></p><h3 id="3-3Junit的技巧"><a href="#3-3Junit的技巧" class="headerlink" title="3.3Junit的技巧"></a>3.3Junit的技巧</h3><p>​    由于@Test等注解都要求方法需要为public、无返回值且无形参。若需要测试的方法不符合这个条件，可以再本类中创建一个符合条件的方法去调用需要测试的方法。</p><p>​    <strong>以@Test为例：</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%8A%80%E5%B7%A7.png" alt="JUnit技巧"></p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>​    上面介绍的注解中，我们实际涉及的只有注解的使用部分，除了使用已经定义好的注解外，我们还可以像定义类和接口那样自己定义注解。</p><h2 id="1-注解的声明"><a href="#1-注解的声明" class="headerlink" title="1.注解的声明"></a>1.注解的声明</h2><p>​        <strong>注解的声明的格式如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    注解类型元素</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注解的关键字为<code>@interface</code>,所有的注解自动继承<strong>java.lang.annotation.Annotation接口</strong> ，注解实现部分只能为<strong>注解类型元素</strong>。</p><h2 id="2元注解"><a href="#2元注解" class="headerlink" title="2元注解"></a>2元注解</h2><p>​     元注解是专门用于修饰注解的注解（注解注解的注解…..），在声明注解时使用。下面是一些常用的元注解</p><h3 id="2-1-Target"><a href="#2-1-Target" class="headerlink" title="2.1 @Target"></a>2.1 @Target</h3><p>​    用来限定此注解可以使用的位置，它使用一个枚举类型ElementType存放不同的常量对象指定不同权限，具体如下。</p><table><thead><tr><th>ElemntType.</th><th>使用位置</th></tr></thead><tbody><tr><td>TYPE</td><td>类，接口（包括注解类型）或枚举的声明</td></tr><tr><td>FIELD</td><td>属性的声明</td></tr><tr><td>METHOD</td><td>方法的声明</td></tr><tr><td>PARAMETER</td><td>方法形式参数声明</td></tr><tr><td>CONSTRUCTOR</td><td>构造方法的声明</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量声明</td></tr><tr><td>ANNOTATION_TYPE</td><td>注解类型声明</td></tr><tr><td>PACKAGE</td><td>包的声明</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Retention"><a href="#2-2-Retention" class="headerlink" title="2.2 @Retention"></a>2.2 @Retention</h3><p>​    用来标记此注解的声明周期，它使用一个枚举类型RetentionPolicy存放不同的常量对象指定不同权限，具体如下。</p><table><thead><tr><th>RetentionPolicy.</th><th>生命周期</th></tr></thead><tbody><tr><td>SOURCE</td><td>编译前</td></tr><tr><td>CLASS</td><td>运行前</td></tr><tr><td>RUNTIME</td><td>运行时</td></tr></tbody></table><p><strong>不同生命周期的效果：</strong></p><ul><li><p>编译前（RetentionPolicy.SOURCE），只存在于.Java文件当中，编译时会被编译器忽略，从而导致此注解不会存在于.class文件当中。实际效果与注释一致。</p></li><li><p>运行前（RetentionPolicy.CLASS），可以编译到.class文件当中，故编译器编译时可以根据注解信息做出相应操作，但在运行时会被JVM所忽略。</p></li><li><p>运行时（RetentionPolicy.RUNTIME），可以在运行时通过反射得到注解信息从而进行相应的判断和操作，是自定义注解所使用最多的权限。</p><p><strong><em>若自定义注解未指定@Retention则默认为RetentionPolicy.CLASS</em></strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Documented"><a href="#2-3-Documented" class="headerlink" title="2.3 @Documented"></a>2.3 @Documented</h3><p>​    用来标记此注解的是否能被JavaDoc生成到API当中。</p><p><strong>示例：</strong></p><p>声明一个带有@Documented的CherryAnnotation注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个不带有@Documented的CherryAnnotation2注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类，同时使用上面两个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CherryAnnotation</span></span><br><span class="line"><span class="meta">@CherryAnnotation2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDocumented</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javadoc导出，结果类中只显示了CherryAnnotation</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Documented%E7%A4%BA%E4%BE%8B.png" alt="Documented示例"></p><h3 id="2-4-Inherited"><a href="#2-4-Inherited" class="headerlink" title="2.4 @Inherited"></a>2.4 @Inherited</h3><p>​    用来标记此注解的是否能被子类继承。</p><p><strong>验证：</strong></p><p>在1.2.2CherryAnnotation注解基础上增加@Inherited</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation是可以被使用者的子类继承的</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造一下测试类,这里涉及到反射的知识，简单来说就是尝试获取子类中的CherryAnnotation（简单使用，代码不规范。不理解的可以先跳过，等到泛型和反射的知识就能理解了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@CherryAnnotation</span><br><span class="line">public class TestDocumented &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class cla &#x3D; TestDocumentedSon.class;</span><br><span class="line">        CherryAnnotation ca &#x3D;(CherryAnnotation)cla.getAnnotation(CherryAnnotation.class);</span><br><span class="line">        System.out.println(ca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestDocumentedSon extends TestDocumented &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码运行结果：</strong></p><p>成功获取到CherryAnnotation，说明子类继承了父类的@CherryAnnotation</p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8Inherited.png" alt="使用Inherited"></p><p><strong>若没有使用@Inherited则不会被使用者的子类所继承，运行结果为null</strong></p><p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8Inherited.png" alt="未使用Inherited"></p><h2 id="3-注解类型元素"><a href="#3-注解类型元素" class="headerlink" title="3.注解类型元素"></a>3.注解类型元素</h2><p>​    注解元素类型是注解特有的一种语法，作用是供读取阶段根据元素的值进行不同操作。由于格式与抽象方法的定义一致，所以有人把注解类型元素叫做注解的抽象方法。又由于调用时需要类似赋值的操作，所以也有的叫做注解的变量/参数。</p><h3 id="3-1-注解类型元素的格式"><a href="#3-1-注解类型元素的格式" class="headerlink" title="3.1 注解类型元素的格式"></a>3.1 注解类型元素的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@元注解</span></span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    修饰符 元素类型 元素名();<span class="comment">//与抽象方法的格式一致</span></span><br><span class="line">        <span class="comment">//可以定义多个注解类型元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有几点需要注意：</strong></p><ul><li>修饰符必须为<strong>public</strong>，若省略则<strong>默认为public</strong>。</li><li>元素的类型只能是 <strong>基本数据类型</strong>、<strong>String</strong>、<strong>Class</strong>、<strong>枚举类型</strong>、<strong>注解类型</strong>（体现了注解的嵌套效果）以及<strong>上述类型的一位数组。</strong></li><li>不能在括号中定义任何参数，仅仅只是一个特殊的语法；</li></ul><h3 id="3-2-传入方式"><a href="#3-2-传入方式" class="headerlink" title="3.2 传入方式"></a>3.2 传入方式</h3><p>​    若定义了注解类型元素，则需要在使用这个注解时传入相应的值,格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@注解名(元素名1 = 传入的值,元素名2 = 传入的值)</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=1)</span><span class="comment">//使用3.1中的CherryAnnotation</span></span><br></pre></td></tr></table></figure><p><strong>有几点需要注意：</strong></p><ul><li>若注解中只定义了一个元素，可以将其命名为<strong>value</strong>，在使用注解时可以省略**元素名 =**，例如元注解中的@Target、@Retention。</li><li>如果没有默认值，使用注解时必须给该类型元素赋值</li><li>默认值的定义方法为在定义元素的后面加上<code>default</code>和（空格）默认值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改造一下CherryAnnotation</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span><span class="keyword">default</span> 1</span>;<span class="comment">//将元素a的默认值设为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;)</span><span class="comment">//使用时不传入a值则默认为1</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=2)</span><span class="comment">//若有传入值则为传入值。</span></span><br></pre></td></tr></table></figure><h2 id="4注解的读取"><a href="#4注解的读取" class="headerlink" title="4注解的读取"></a>4注解的读取</h2><p><strong>由于涉及反射内容，整理完Java基础之反射后再更新</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;注解（Annotation）&lt;/code&gt;可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为&lt;code&gt;@interface&lt;/code&gt;，使用时的格式为&lt;code&gt;@注解名&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>markdown常用语法</title>
    <link href="http://yoursite.com/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-05T08:26:21.000Z</published>
    <updated>2020-08-07T09:44:21.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h1><p>​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。</p><a id="more"></a><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><h3 id="0-标题"><a href="#0-标题" class="headerlink" title="0.标题"></a>0.标题</h3><p>​    标题格式：<strong># + 空格 + 标题内容</strong>，几个’#就代表几级标题。</p><h3 id="1-字体"><a href="#1-字体" class="headerlink" title="1.字体"></a>1.字体</h3><p>​        字体格式：<strong>*文本内容* 或  _文本内容_</strong> ，一个符号为<em>斜体文本</em>，两个符号为<strong>粗体文本</strong>，三个符号为**<em>粗斜体文本**</em>。</p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">*斜体文本* 或  _斜体文本_</td><td align="center"><em>斜体文本</em></td></tr><tr><td align="center">**粗体文本** 或 __粗体文本__</td><td align="center"><strong>粗体文本</strong></td></tr><tr><td align="center">***粗斜体文本*** 或 ___粗斜体文本___</td><td align="center"><strong><em>粗斜体文本</em></strong></td></tr></tbody></table><h3 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2.删除线"></a>2.删除线</h3><p>​        删除线格式：<strong>~~删除线文本~~</strong></p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">普通文本</td><td align="center">普通文本</td></tr><tr><td align="center">~~删除线文本~~</td><td align="center"><del>删除线文本</del></td></tr></tbody></table><h3 id="3-下划线"><a href="#3-下划线" class="headerlink" title="3.下划线"></a>3.下划线</h3><p>​        下划线格式：<strong>&lt;u&gt;带下划线的文本&lt;/u&gt;</strong></p><table><thead><tr><th align="center">输入内容</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">普通文本</td><td align="center">普通文本</td></tr><tr><td align="center">&lt;u&gt;带下划线的文本&lt;/u&gt;</td><td align="center"><u>带下划线的文本</u></td></tr></tbody></table><h3 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h3><p>​    <strong>使用脚注</strong>：文本内容[^脚注名称]，<strong>解释脚注：</strong>[^脚注名称]:脚注内容。</p><p>​    <strong>效果</strong>：文本内容<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^脚注</a></p><h3 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h3><p>​    使用三个或以上 * 或 - 来使用下划线，可以在符号中加空格（可能会在编写软件中识别为其他符号，<strong>不建议使用</strong>），且本行中不可有其他内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">几种分割线示意：</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>分割线效果：</p><hr><p><strong>错误示范</strong>：***其他内容（未出现分割线效果）</p><h2 id="列表与区块"><a href="#列表与区块" class="headerlink" title="列表与区块"></a>列表与区块</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    无序列表格式：<strong>* 或 + 或 - 加上一个空格后面再加上内容</strong>，三个符号效果相同。</p><p><strong>输入</strong>：</p><p>​    * 无序第一列</p><p>​    + 无序第二列</p><p>​    -  无序第三列</p><p><strong>效果</strong>：</p><pre><code>    * 无序第一列</code></pre><ul><li>无序第二列</li></ul><ul><li>无序第三列</li></ul><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​    有序列表格式：<strong>数字+ . + 空格 + 内容</strong>，即将无序列表的符号替换为数字加点的格式（例如1.）。</p><p><strong>输入</strong>：</p><p>​    1. 有序第一列</p><p>​    2. 有序第二列</p><p>​    3. 有序第三列</p><p><strong>效果</strong>:</p><ol><li>有序第一列</li><li>有序第二列</li><li>有序第三列</li></ol><h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​    在语法中为在<strong>子列表前添加四个空格</strong>，不过一般都在编写软件上编写<strong>更推荐使用TAB（缩进）与SHIFT+TAB（反缩进）</strong></p><p>​    <strong>输入</strong>：</p><p>​    1. 第一项：</p><p>​        * 第一项嵌套的第一个元素</p><p>​        * 第一项嵌套的第二个元素</p><p>​    2. 第二项：</p><p>​        * 第二项嵌套的第一个元素</p><p>​        * 第二项嵌套的第二个元素</p><p><strong>效果</strong>:</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<pre><code>* 第二项嵌套的第一个元素   * 第二项嵌套的第二个元素</code></pre></li></ol><h3 id="4-区块"><a href="#4-区块" class="headerlink" title="4.区块"></a>4.区块</h3><p>​    区块格式：<strong>在每行前加上 &gt; 然后紧跟一个空格。</strong></p><p><strong>输入：</strong></p><p>&gt; 区块引用第一行</p><p>&gt; 区块引用第二行</p><p><strong>效果：</strong></p><blockquote><p>区块引用第一行</p><p>区块引用第二行</p></blockquote><h3 id="5-区块嵌套"><a href="#5-区块嵌套" class="headerlink" title="5.区块嵌套"></a>5.区块嵌套</h3><p>​    区块嵌套格式：<strong>每有一个 &gt; 号就表示一层嵌套</strong></p><p><strong>输入：</strong></p><p>&gt; 最外层</p><p>&gt;&gt; 第一层嵌套</p><p>&gt;&gt;&gt; 第二层嵌套</p><p>**效果: **</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-代码片段"><a href="#1-代码片段" class="headerlink" title="1.代码片段"></a>1.代码片段</h3><p>​    代码片段格式：**` 代码内容 ` **(反引号)</p><p>​    <strong>输入：</strong> ` int a ;`         <strong>效果：</strong> <code>int a;</code></p><h3 id="2-代码区块"><a href="#2-代码区块" class="headerlink" title="2.代码区块"></a>2.代码区块</h3><p>​    格式：用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><p><strong>输入：</strong></p><p>​    ``` java</p><p>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(“Hello World”);<br>    }<br>}</p><p>​    ```</p><p><strong>效果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="1-直接显示链接"><a href="#1-直接显示链接" class="headerlink" title="1.直接显示链接"></a>1.直接显示链接</h3><p>​    语法格式: <strong>&lt; 链接 &gt; **    **效果:</strong> <a href="https://www.baidu.com/">https://www.baidu.com/</a></p><h3 id="2-用名称替代链接"><a href="#2-用名称替代链接" class="headerlink" title="2.用名称替代链接"></a>2.用名称替代链接</h3><p>​    语法格式：**[链接名称](链接地址)  **效果：这是我的<a href="https://ykailh.github.io/">博客</a></p><h3 id="3-用名称和变量替代链接"><a href="#3-用名称和变量替代链接" class="headerlink" title="3.用名称和变量替代链接"></a>3.用名称和变量替代链接</h3><p>​    语法格式：<strong>[链接名称][变量名称]，[变量名称]</strong>: 链接。变量定义类似于脚注，效果与用名称替代类似，但方便多次使用。</p><p>效果：这是一个<a href="https://www.baidu.com/">百度链接</a>，再次使用<a href="https://www.baidu.com/">百度链接</a>。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    <strong>用 | 来分隔单元格，- 来分隔表头。</strong></p><p><strong>输入：</strong></p><p>| 表头 | 表头 |</p><p>|  —-  |  —-  |</p><p>| 单元格 | 单元格 |</p><p>| 单元格 | 单元格 |</p><p><strong>效果：</strong></p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>默认为左对齐</strong></p><hr><p>将分隔符替换为<strong>-: , :-  , :-:</strong> 分别表示右对齐，左对齐，居中对齐。</p><p><strong>输入：</strong></p><p>| 左对齐 | 右对齐 | 居中对齐 |</p><p>|  :—-  |  —-:  | :—-: |</p><p>| 单元格 | 单元格 | 单元格 |</p><p>| 单元格 | 单元格 | 单元格 |</p><p><strong>效果</strong>：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>​    图片插入格式：![图片名](图片相对路径/绝对路径/图片链接)；</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>​    编写md文件时建议使用专用的编辑器，一般都支持自动补全和实时预览，可以提高编写的效率。博主正在用的也是许多人推荐的Typora,也推荐给大家。<a href="https://www.typora.io/">Typora官网</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown常用语法&quot;&gt;&lt;a href=&quot;#markdown常用语法&quot; class=&quot;headerlink&quot; title=&quot;markdown常用语法&quot;&gt;&lt;/a&gt;markdown常用语法&lt;/h1&gt;&lt;p&gt;​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用软件" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="Typora" scheme="http://yoursite.com/tags/Typora/"/>
    
      <category term="常用软件" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
