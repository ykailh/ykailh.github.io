<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Ykailh" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Ykailh</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle">面朝大海，春暖花开</span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-Java基础之集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/11/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/"
    >Java基础之集合</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/11/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-08-11T08:56:32.000Z" itemprop="datePublished">2020-08-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​    <strong>本章内容主要是对Java中的集合的简单了解以及使用，在深入学习数据结构再进行学习和总结。</strong></p>
<h1 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h1><h2 id="1-什么是集合"><a href="#1-什么是集合" class="headerlink" title="1.什么是集合"></a>1.什么是集合</h2><p>​    集合是用来存放<strong>数据的容器</strong>，主要有<code>set(集)</code>、<code>list(列表)</code>、<code>map(映射)</code>三种。</p>
<p>​    与集合类似的还有之前接触到的数组，<strong>集合与数组的主要区别</strong>如下：</p>
<ul>
<li>数组的长度是固定的，集合的长度是可变的。</li>
<li>数组可以存放基本数据类型也可以存放引用数据类型，集合只能存放引用数据类型。</li>
<li>数据的读取速度快于集合，但占用连续的内存空间。</li>
</ul>
<h2 id="2-简单了解几个数据结构"><a href="#2-简单了解几个数据结构" class="headerlink" title="2.简单了解几个数据结构"></a>2.简单了解几个数据结构</h2><p>​    每个集合的<strong>底层存储方式</strong>可能都不同，导致了每个集合都有自己的<strong>性能特性</strong>，在实际使用中根据需求选择不同的集合。为了意识到这一点，简单介绍一些数据结构。</p>
<ul>
<li><p><strong>数组</strong></p>
<p>​    数组的底层存储方式是根据数组的长度开辟<strong>一段连续的内存空间</strong>，将这段内存的<strong>首地址</strong>存放到以数组名为变量名的变量中，访问数据时根据<strong>首地址以及数组下标（偏移量）</strong>计算出数据所在的地址，访问数据。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/%E6%95%B0%E7%BB%84.png" alt="数组"></p>
</li>
<li><p><strong>链表</strong></p>
<p>​    链表的底层存储方式是，将数据存放到不要求内存连续的空间中，每个内存空间称为一个信息节点。信息节点除了包含存储的数据外还包含<strong>下一个节点的地址值</strong>，访问数据时需要<strong>从第一个节点开始</strong>，读取节点中的地址值，在根据这个地址值去查找下一个节点，以此类推<strong>直到查询到的数据为止</strong>。这样的链表称为<strong>单向链表</strong>。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表"></p>
<p>若在节点中同时存放上一个节点的地址，则从两侧均可访问链表，这样的链表称为双向链表。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
</li>
<li><p><strong>二叉树</strong></p>
<p>​    二叉树的底层存储方式同样是讲数据存放到节点中，节点中包含<strong>上一个节点（父节点）的地址值</strong>，以及<strong>另外两个子节点的地址值</strong>。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p>
<p>更多的数据结构以后再专门整理，主要目的是理解各个集合间的性能差异和原因。</p>
</li>
<li><p><strong>哈希表</strong></p>
<p>哈希表的篇幅较长也比较复杂，推荐一篇小白向的文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_33921105/article/details/103344078?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.wap_blog_relevant_pic2&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.wap_blog_relevant_pic2">一文彻底搞定哈希表</a>，可以快速简单理解哈希表。</p>
</li>
</ul>
<h2 id="3-集合在Java中的实现"><a href="#3-集合在Java中的实现" class="headerlink" title="3.集合在Java中的实现"></a>3.集合在Java中的实现</h2><p>​    集合一般都需要增、删、改、查等基本功能，为此Java在<code>java.util</code>包下提供了两个接口（也可以称为结合的根接口），分别为针对对象的集合接口：<code>Collection</code>以及针对键值对的集合接口：<code>Map</code>。这两个接口都分别有许多实现类，提供了多种集合的选择。</p>
<h1 id="Collection家族"><a href="#Collection家族" class="headerlink" title="Collection家族"></a>Collection家族</h1><p>​    Collection家族中包含<code>List</code>系列集合和<code>Set</code>系列集合，主要用于存放<strong>单值元素</strong>。</p>
<h2 id="1-Collection提供的方法"><a href="#1-Collection提供的方法" class="headerlink" title="1.Collection提供的方法"></a>1.Collection提供的方法</h2><p>​    如上述所说，作为集合的根父类之一提供了一些集合通用的方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add（E e）</td>
<td>添加元素到集合末尾</td>
</tr>
<tr>
<td>boolean addAll（Collection c）</td>
<td>将集合c中元素添加到该集合中</td>
</tr>
<tr>
<td>void clean()</td>
<td>移除集合中的所有元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否有指定元素</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>判断该集合是否拥有全部的集合c中的元素（判断c是否为子集）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>移除集合中的指定元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>移除该集合中的同时存在于集合c中的元素（移除交集部分）</td>
</tr>
<tr>
<td>int size()</td>
<td>返回集合中的元素个数</td>
</tr>
<tr>
<td>Object toArray()</td>
<td>返回包含该集合所有元素的Object类型的数组</td>
</tr>
<tr>
<td>&lt;T&gt;  &lt;T&gt;[] toArray(&lt;T&gt;[])</td>
<td>返回包含该集合所有元素的指定类型的数组</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否为空集合（不包含元素）</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回哈希值</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>判断集合与指定元素是否相等</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; iterator()</td>
<td>返回迭代器，迭代器的作用在之后说明。</td>
</tr>
</tbody></table>
<h2 id="2-Collection集合的遍历"><a href="#2-Collection集合的遍历" class="headerlink" title="2.Collection集合的遍历"></a>2.Collection集合的遍历</h2><ul>
<li><p><strong>方式一：</strong>返回元素的数组再遍历这个数组</p>
<p>在没有学习迭代器之前使用的方法，也可以当做一种思路。</p>
</li>
<li><p><strong>方式二：</strong>使用迭代器遍历</p>
<p>因为每个集合的底层存储方式的不同，导致无法使用统一的方式访问集合内的元素。所有Java提供了一个迭代器接口：<code>java.util.Iterator</code>，里面定义了几个方法分别为：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断是否有可迭代的元素（判断是否有下一个元素）</td>
</tr>
<tr>
<td>&lt;E&gt; next()</td>
<td>返回迭代的下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>移除当前迭代器指向的元素（<strong>这个是默认方法</strong>）</td>
</tr>
</tbody></table>
<p>不同的集合只需要在实现这个接口就可以<strong>解决不能统一访问方式</strong>的问题，实现方式一般是在集合类中定义一个<strong>内部类</strong>来实现这个接口，这也是设计模式之一的<strong>迭代器模式</strong>。</p>
</li>
<li><p><strong>方式三：</strong>使用<code>forearm</code>遍历</p>
<p>可以使用一个<strong>特殊的for循环</strong>进行遍历，格式为<code>for(数据类型 临时变量名:集合名)</code>。使用forearm循环的前提是实现了<code>java.lang.Iterable</code>接口，这个接口中只有一个方法<strong>需要返回一个迭代器</strong>。所以forearm的实现其实也是<strong>依靠于迭代器</strong>的，只不过是使用上更加方便。</p>
</li>
</ul>
<p><strong>若只需要遍历集合建议使用<code>forearm</code>，若涉及到删除则建议使用方式二。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ArrayList是Collection的一个实现类，后面会讲到</span></span><br><span class="line">    Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    c.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转化为数组后再进行遍历</span></span><br><span class="line">    String[] cArray = c.toArray(<span class="keyword">new</span> String[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cArray.length; i++) &#123;</span><br><span class="line">        System.out.println(cArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代器进行遍历</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = c.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        String str = iterator.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用forearm遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String str : cArray) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-List系列集合"><a href="#3-List系列集合" class="headerlink" title="3.List系列集合"></a>3.List系列集合</h2><p>​    <code>List</code>为<code>Collection</code>的子接口，实现这个接口的集合具有元素<strong>有序</strong>、<strong>可重复</strong>的特点，一般称之为<strong>列表</strong>。</p>
<h3 id="List提供的方法"><a href="#List提供的方法" class="headerlink" title="List提供的方法"></a>List提供的方法</h3><p>​    <code>LIst</code>中除了提供<code>Collection</code>中的方法外，还提供了以下方法：<strong>E为存储元素类型</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index , E element)</td>
<td>将元素（按照下标）插入到指定位置</td>
</tr>
<tr>
<td>boolean addAll（int index , Collection&lt;? extends E&gt; c）</td>
<td>将列表c的所有元素插入到指定位置</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回列表中指定的元素</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>返回列表中o元素第一次出现的索引（下标），若没有该元素返回-1。</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>返回列表中o元素最后一次出现的索引（下标），若没有该元素返回-1。</td>
</tr>
<tr>
<td>E remove（int index）</td>
<td>根据下标删除指定元素，返回被删除的元素。</td>
</tr>
<tr>
<td>E set(int index,E element)</td>
<td>替换指定位置的元素，返回被替换的元素。</td>
</tr>
<tr>
<td>List&lt;E&gt; subList(int feomIndex，int toIndex)</td>
<td>返回包含列表fromIndex（包括）到toIndex（不包括）之间元素的新列表。</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; listIterator()</td>
<td>返回列表迭代器。</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; listIterator(int index)</td>
<td>返回从指定元素开始的列表迭代器。</td>
</tr>
</tbody></table>
<p>其中最值得说明的是<code>ListIterator</code>，这是<code>Iterator</code>的一个子接口，是<code>List</code>集合专用的迭代器，提供了更多的方法，新增方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int nextIndex()</td>
<td>返回列表中下一个元素的索引</td>
</tr>
<tr>
<td>void add(E e)</td>
<td>将元素插入列表</td>
</tr>
<tr>
<td>boolean hasPrevious()</td>
<td>逆向遍历列表，判断是否有可迭代元素。</td>
</tr>
<tr>
<td>E previous()</td>
<td>返回列表的前一个元素</td>
</tr>
<tr>
<td>int previousIndex()</td>
<td>返回上一个元素的索引</td>
</tr>
<tr>
<td>void set(E e)</td>
<td>替换列表中的元素</td>
</tr>
<tr>
<td>void add(int index,E e)</td>
<td>将元素插入到的指定位置（这个方法重载在集合类中）</td>
</tr>
<tr>
<td>void set(int index,E e)</td>
<td>将元素替换到的指定位置（这个方法重载在集合类中）</td>
</tr>
</tbody></table>
<p>一般的List系列集合都可以使用索引操作，但实际性能根据底层存储方式的不同而不同。</p>
<h3 id="List的常用实现类"><a href="#List的常用实现类" class="headerlink" title="List的常用实现类"></a>List的常用实现类</h3><ul>
<li><p><strong>Vector（向量）</strong></p>
<p><code>Vector</code>底层数据结构为<strong>数组</strong>，默认<strong>初始容量为10</strong>，超出容量时扩容为原来的<strong>2倍</strong>，最大的特点是它是<strong>线程安全</strong>的。提供改变初始容量的构造器和增量的构造器。</p>
</li>
<li><p><strong>ArrayList（动态数组）</strong></p>
<p><code>ArrayList</code>底层数据结构为<strong>数组</strong>，默认<strong>初始容量为0</strong>，<strong>第一次使用时容量变为10</strong>，超出容量时扩容为原来的<strong>1.5倍</strong>，<strong>线程不安全。</strong>提供改变初始容量的构造器。</p>
</li>
<li><p><strong>Stack（栈）</strong></p>
<p><code> Stack</code>是 <code> Vector</code>的子类，它的最大特点是<strong>后进先出</strong>，可以理解为一个朝上开口的箱子，最后放进去的东西在箱子的最上面，想要拿到箱子底部的东西就必须把上面的东西拿开。但它的底层仍旧为<strong>数组</strong>。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/%E6%A0%88.jpg" alt="栈"></p>
<p>相比于<code>Vector</code>多提供了<strong>栈独有的操作方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>E peek()</td>
<td>查看栈顶对象</td>
</tr>
<tr>
<td>E pop()</td>
<td>移除并返回栈顶对象</td>
</tr>
<tr>
<td>E push（E item）</td>
<td>把对象放到栈顶（压栈），相当于add（E item）</td>
</tr>
<tr>
<td>int search(Object o)</td>
<td>返回对象在栈中的位置，以1位基数</td>
</tr>
<tr>
<td>boolean empty()</td>
<td>判断栈是否为空</td>
</tr>
</tbody></table>
</li>
<li><p><strong>LinkedList（双向链表）</strong></p>
<p><code>LinkedList</code>的底层为<strong>双向链表</strong>，所以<strong>不推荐使用索引</strong>进行访问，是<strong>线程不安全</strong>的。除了操作双向链表的方法外，<code>LinkedList</code>还实现了<code>java.util.Deque</code>接口来支持用作<strong>双端队列</strong>、<strong>队列（先进先出）</strong>、<strong>单向链表</strong>、<strong>栈（后进先出）</strong>等各种数据结构，是一个十分强大的集合类。</p>
</li>
</ul>
<h2 id="4-Set系列集合"><a href="#4-Set系列集合" class="headerlink" title="4.Set系列集合"></a>4.Set系列集合</h2><p>​    <code>Set</code>系列集合是<strong>部分有序</strong>、但都<strong>不可重复</strong>的，<code>Set</code>接口除了<code>Collection</code>提供的方法外<strong>没有额外提供方法</strong>。</p>
<h3 id="Set的常用实现类"><a href="#Set的常用实现类" class="headerlink" title="Set的常用实现类"></a>Set的常用实现类</h3><p>​    Set系列底层对应与不同的<code>Map</code>系列集合，想要了解底层实现可以先学习<code>Map</code>系列集合。</p>
<ul>
<li><p><strong>HashSet</strong></p>
<p><code>HashSet</code>实际为<code>HashMap</code>，元素无序且唯一。保证元素唯一的方式是<strong>先比较存储对象的哈希值</strong>，若<strong>哈希值相同</strong>再通过<code>equals()</code>方法比较是否相等。</p>
</li>
<li><p><strong>LinkedHashSet</strong></p>
<p><code>LinkedHashSet</code>是<code>HaseSet</code>的子类,实际为<code>LinkedHashMap</code>，相比于父类增加了保证<strong>元素添加顺序</strong>的特性。</p>
</li>
<li><p><strong>TreeSet</strong></p>
<p><code>TreeSet</code>实际为<code>TreeMap</code>，元素<strong>按照大小排序且保证唯一</strong>。通过元素大小判断的方式来保证元素的唯一性，若<strong>元素大小相等则认为是相同元素</strong>。要求存储的元素必须实现<code>java.lang.Comparable</code>接口或在创建<code>TreeSet</code> 时指定一个<code>java.util.Comparator</code>接口。</p>
</li>
</ul>
<h2 id="5-Collection家族集合的选择"><a href="#5-Collection家族集合的选择" class="headerlink" title="5.Collection家族集合的选择"></a>5.Collection家族集合的选择</h2><p>​    根据不同集合的特性，简单的按照用途选择不同的集合如下图：</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/Collection%E9%9B%86%E5%90%88%E9%80%89%E6%8B%A9.png" alt="Collection集合选择"></p>
<h1 id="Map家族"><a href="#Map家族" class="headerlink" title="Map家族"></a>Map家族</h1><p>​    <code>Map</code>系列集合主要用于存<strong>放键值对元素</strong>也叫做<strong>映射项（Entry）</strong>。</p>
<h2 id="1-Mpa提供的方法"><a href="#1-Mpa提供的方法" class="headerlink" title="1.Mpa提供的方法"></a>1.Mpa提供的方法</h2><p>​    K为key的类型，V为value的类型</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>V  put(K key , V value)</td>
<td>添加一个键值对，返回value的值。</td>
</tr>
<tr>
<td>void putAll(Map&lt;? extends K, ? extends V&gt; m)</td>
<td>将集合M的键值对添加到该集合中。</td>
</tr>
<tr>
<td>V get(K key）</td>
<td>返回key对应的value值</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据key值删除键值对，返回被删除的value值。</td>
</tr>
<tr>
<td>void clear()</td>
<td>删除集合中的所有元素。</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断Key是否存在</td>
</tr>
<tr>
<td>boolean containsValue(Object Value)</td>
<td>判断Value是否存在</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取包含所有键值对的Set集合</td>
</tr>
<tr>
<td>Set&lt;K&gt;  keySet()</td>
<td>获取包含所有Key的Set集合</td>
</tr>
<tr>
<td>Collection&lt;V&gt;  values()</td>
<td>获取包含所有value值的Collection集合</td>
</tr>
<tr>
<td>int size()</td>
<td>获取集合中键值对数量</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否为空集合（不包含元素）</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回哈希值</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>判断集合与指定元素是否相等</td>
</tr>
</tbody></table>
<h2 id="2-Map集合的遍历"><a href="#2-Map集合的遍历" class="headerlink" title="2.Map集合的遍历"></a>2.Map集合的遍历</h2><p>​    由于<code>Map</code>接口并没有实现<code>java.lang.Iterable</code>接口所以不能直接使用<code>foreach</code>遍历</p>
<ul>
<li><strong>方法一：</strong>调用<code>Collection&lt;V&gt;  values()</code>方法再遍历返回的集合</li>
<li><strong>方法二：</strong>调用<code>Set\&lt;K&gt;  keySet()</code>方法再遍历返回的集合，在遍历中通过<code>V get(K key）</code>获取<code>value</code></li>
<li><strong>方法三：</strong>调用<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>方法再遍历返回的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    Collection&lt;String&gt; values = map.values();</span><br><span class="line">    <span class="keyword">for</span> (String string : values) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : keySet) &#123;</span><br><span class="line">        System.out.println(map.get(integer));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    Set&lt;Entry&lt;Integer,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, String&gt; entry : entrySet) &#123;</span><br><span class="line">        System.out.println(entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Map的常用实现类"><a href="#3-Map的常用实现类" class="headerlink" title="3.Map的常用实现类"></a>3.Map的常用实现类</h2><p>​    <code>Map</code>系列的<code>key</code>均为<strong>唯一值</strong>。</p>
<ul>
<li><p><strong>Hashtable</strong></p>
<p><code>Hashtable</code>是<strong>线程安全</strong>的，<code>key</code>和<code>value</code>不能为<code>null</code>，不保证元素插入顺序。</p>
</li>
<li><p><strong>HashMap</strong></p>
<p><code>HashMap</code>是<strong>线程不安全</strong>的，<code>key</code>和<code>value</code>可以为<code>null</code>。除此之外基本上与<code>Hashtable</code>一致，类似<code>Vector</code>与<code>ArrayList</code>的关系。<code>Jdk1.8</code>之后底层实现为<strong>数组+链表/红黑树</strong>。</p>
</li>
<li><p><strong>LinkedHashMap</strong></p>
<p><code>LinkedHashMap</code>为<code>HashMap</code>的子类，相比于父类增加了保证<strong>元素添加顺序</strong>的特性。</p>
</li>
<li><p><strong>TreeMap</strong></p>
<p>键值对按照<code>key</code>的大小顺序进行排序。</p>
</li>
<li><p><strong>Properties</strong></p>
<p><code>Properties</code>是<code>Hashtable</code>的子类，它的<code>key</code>与<code>value</code>均为<code>String</code>类型，常用于存储配置属性。添加了一些方法，遇到时再进行讲解。</p>
</li>
</ul>
<p><strong><em>目前可以先了解使用，关于Map的底层实现留到源码分析时专门讲解</em></strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础之多线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
    >Java基础之多线程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-08-10T04:48:54.000Z" itemprop="datePublished">2020-08-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h1><ol>
<li><p>进程</p>
<p>​    进程是<strong>操作系统分配资源的最小单位</strong>。可以简单理解为每运行一个程序就是一个进程。进程之间的资源是独立的，无法直接共享。</p> 
      <a class="article-more-link" href="/2020/08/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础之字符串"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"
    >Java基础之字符串</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time datetime="2020-08-09T13:52:36.000Z" itemprop="datePublished">2020-08-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h1><p>​        <strong><em>以下说明及演示基于JDK1.8版本</em></strong></p>
<ol>
<li>字符串String类型本身是final声明的，字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象。</li>
<li>String对象内部是用数组进行保存的，在<strong>JDK1.9之前</strong>用的是字符数组<code>char[]</code>，<strong>JDK1.9之后</strong>使用的是字节数组<code>byte[]</code>。</li>
</ol> 
      <a class="article-more-link" href="/2020/08/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础之包装类"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"
    >Java基础之包装类</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/" class="article-date">
  <time datetime="2020-08-08T07:48:54.000Z" itemprop="datePublished">2020-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h1><p>​    Java作为面向对象的编程语言在设计之初依然延续了C语言的8种基本数据类型，但在不断的更新中设计了很多针对对象的API和新的特性（例如泛型），不支持基本数据类型。为了解决这个问题，Java为每一个基本数据类型提供了包装类。</p> 
      <a class="article-more-link" href="/2020/08/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/" rel="tag">包装类</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础之异常"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"
    >Java基础之异常</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2020-08-07T11:28:14.000Z" itemprop="datePublished">2020-08-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>​    在一些情况下，由于<strong>非程序本身</strong>问题，例如:配置问题、错误输入、磁盘空间不足等等所导致的程序无法正常运行。</p> 
      <a class="article-more-link" href="/2020/08/07/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础之注解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"
    >Java基础之注解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-08-06T06:36:27.000Z" itemprop="datePublished">2020-08-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>​    <code>注解（Annotation）</code>可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为<code>@interface</code>，使用时的格式为<code>@注解名</code>。</p> 
      <a class="article-more-link" href="/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-markdown常用语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"
    >markdown常用语法</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2020-08-05T08:26:21.000Z" itemprop="datePublished">2020-08-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/">常用软件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h1><p>​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。</p> 
      <a class="article-more-link" href="/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/" rel="tag">常用软件</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> Ykailh
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Ykailh"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>