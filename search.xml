<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础之注解</title>
    <url>/2020/08/06/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>​    <code>注解（Annotation）</code>可以理解为是一种特殊的注释，用于为代码提供元数据。一个完整的注解由声明、使用、读取三个部分组成。注解的修饰符为<code>@interface</code>，使用时的格式为<code>@注解名</code>。</p>
<a id="more"></a>

<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="1-基本注解"><a href="#1-基本注解" class="headerlink" title="1.基本注解"></a>1.基本注解</h2><p>​    基本注解是Java提供的最基础的几个注解，在<code>JDK1.5</code>版本加入注解时提供了三个基本注解，定义在<code>java.lang</code>包下</p>
<h3 id="1-1-Override"><a href="#1-1-Override" class="headerlink" title="1.1 @Override"></a>1.1 @Override</h3><p>​    使用在方法上，用于检查这个方法是否符合重写的要求，同时可以作为重写方法的标记，增加代码的可读性。若检查不符合重写要求则会在编译时报错。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%8A%A5%E9%94%99.png" alt="Override报错"></p>
<p>​    上图中若去掉@Override则正常识别为方法重载。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E5%8E%BB%E6%8E%89Override.png" alt="去掉Override"></p>
<p>​    正确重写方法时，报错消失，对于程序而言有无Override没有区别。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Override%E6%AD%A3%E7%A1%AE%E9%87%8D%E5%86%99.png" alt="Override正确重写"></p>
<h3 id="1-2-SuppressWarnings"><a href="#1-2-SuppressWarnings" class="headerlink" title="1.2 @SuppressWarnings"></a>1.2 @SuppressWarnings</h3><p>​    可以使用在类，字段，方法，参数，构造方法，局部变量上。用于抑制编译器的警告信息。</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(“参数”)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;“参数1”，“参数2”.....&#125;)</span></span><br></pre></td></tr></table></figure>

<p>通过参数选择一个或多个抑制警告的种类。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">抑制类型</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td align="left">抑制所有类型的警告</td>
</tr>
<tr>
<td>boxing</td>
<td align="left">抑制装箱、拆箱相关的警告</td>
</tr>
<tr>
<td>cast</td>
<td align="left">抑制映射相关的警告</td>
</tr>
<tr>
<td>dep-ann</td>
<td align="left">抑制启用注释的警告</td>
</tr>
<tr>
<td>deprecation</td>
<td align="left">抑制过期方法警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td align="left">抑制switch中缺失breaks的警告</td>
</tr>
<tr>
<td>finally</td>
<td align="left">抑制finally模块没有返回的警告</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td align="left">忽略没有完整的switch语句</td>
</tr>
<tr>
<td>nls</td>
<td align="left">忽略非nls格式的字符</td>
</tr>
<tr>
<td>null</td>
<td align="left">忽略对null的操作</td>
</tr>
<tr>
<td>rawtypes</td>
<td align="left">使用generics时忽略没有指定相应的类型</td>
</tr>
<tr>
<td>serial</td>
<td align="left">忽略在serializable类中没有声明serialVersionUID变量</td>
</tr>
<tr>
<td>static-access</td>
<td align="left">抑制不正确的静态访问方式警告</td>
</tr>
<tr>
<td>synthetic-access</td>
<td align="left">抑制子类没有按最优方法访问内部类的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td align="left">抑制没有进行类型检查操作的警告</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td align="left">抑制没有权限访问的域的警告</td>
</tr>
<tr>
<td>unused</td>
<td align="left">抑制没被使用过的代码的警告</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<p>​        定义变量a但未使用，编译器抛出警告。</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="未使用SuppressWarnings"></p>
<p>使用SuppressWarnings后</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8SuppressWarnings.png" alt="使用SuppressWarnings"></p>
<h3 id="1-3-Deprecated"><a href="#1-3-Deprecated" class="headerlink" title="1.3 @Deprecated"></a>1.3 @Deprecated</h3><p>​    可以使用在类、方法、属性上，用于标记此方法已经废弃。由于java对修改关闭，对扩展开放的原则，已经废弃的方法一般不会直接删除，而是使用这个注解去标记它。</p>
<p>源代码中对已过期方法的标记：</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84Deprecated.png" alt="源代码中的Deprecated"></p>
<p>自己使用@Deprecated：</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8Deprecated.png" alt="自己使用Deprecated"></p>
<h2 id="2-文档注解"><a href="#2-文档注解" class="headerlink" title="2.文档注解"></a>2.文档注解</h2><p>​    文档注解通常用于说明和记录程序的信息，以/** 开始，以 */结束。其中有一些用于标记信息内容的注解，建议养成编写文档注解的习惯，后续作为javadoc生成API的内容。</p>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="left">标识一个类的作者</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="left">指名一个过期的类或成员</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="left">标志一个类抛出的异常</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="left">说明一个方法的参数</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="left">说明返回值类型</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="left">指定一个到另一个主题的链接</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="left">说明一个序列化属性</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="left">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="left">说明一个ObjectStreamField组件</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="left">标记当引入一个特定的变化时</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="left">和 @exception标签一样</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="left">指定类的版本</td>
</tr>
</tbody></table>
<p>可以参考源码中的文档注解</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E8%A7%A3.png" alt="源码中的文档注解"></p>
<p><strong>格式规范：</strong></p>
<p>@param 形参名 形参数据类型 解释。（每个形参单独写一个@param）</p>
<p>@return 返回值类型 解释。（若为void则省略）</p>
<p>@throws 异常类型名 解释（每个可能抛出的异常单独写一个@throws，没有则省略）</p>
<p><strong>文档注解与代码请时刻保持一致！</strong></p>
<h2 id="3-JUnit"><a href="#3-JUnit" class="headerlink" title="3.JUnit"></a>3.JUnit</h2><p>​    JUnit是一个回归测试框架，常用于编写单元测试，现在多数开发环境中都集成了JUnit。使用Eclipse做一个简单的说明。</p>
<h3 id="3-1-使用JUnit"><a href="#3-1-使用JUnit" class="headerlink" title="3.1 使用JUnit"></a>3.1 使用JUnit</h3><p>​    右键项目选择 Build Part → Add Library</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit1.png" alt="使用JUnit1"></p>
<p>​    选择JUnit 然后完成（下一步可以选择JUnit的版本和路径）</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit2.png" alt="使用JUnit2"></p>
<p>​    添加成功</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8JUnit3.png" alt="使用JUnit3"></p>
<h3 id="3-2-JUnit中的注解"><a href="#3-2-JUnit中的注解" class="headerlink" title="3.2 JUnit中的注解"></a>3.2 JUnit中的注解</h3><p>（1）@Test：表示它是一个单元测试方法</p>
<p>这个方法需要是：public void xxx(){}</p>
<p>（2）@Before：表示在每一个单元测试方法之前执行</p>
<p>这个方法需要是：public void xxx(){}</p>
<p>（3）@After：表示在每一个单元测试方法之后执行</p>
<p>这个方法需要是：public void xxx(){}</p>
<p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p>
<p>这个方法需要是：public static void xxx(){}</p>
<p>（5）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p>
<p>这个方法需要是：public static void xxx(){}</p>
<p><strong>执行顺序测试：</strong></p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUni%E6%B5%81%E7%A8%8B.png" alt="JUni流程"></p>
<p><strong>执行结果：</strong></p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%9C.png" alt="JUnit流程结果"></p>
<p><strong>执行流程图：</strong></p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="JUnit流程图"></p>
<h3 id="3-3Junit的技巧"><a href="#3-3Junit的技巧" class="headerlink" title="3.3Junit的技巧"></a>3.3Junit的技巧</h3><p>​    由于@Test等注解都要求方法需要为public、无返回值且无形参。若需要测试的方法不符合这个条件，可以再本类中创建一个符合条件的方法去调用需要测试的方法。</p>
<p>​    <strong>以@Test为例：</strong></p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/JUnit%E6%8A%80%E5%B7%A7.png" alt="JUnit技巧"></p>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>​    上面介绍的注解中，我们实际涉及的只有注解的使用部分，除了使用已经定义好的注解外，我们还可以像定义类和接口那样自己定义注解。</p>
<h2 id="1-注解的声明"><a href="#1-注解的声明" class="headerlink" title="1.注解的声明"></a>1.注解的声明</h2><p>​        <strong>注解的声明的格式如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    注解类型元素</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注解的关键字为<code>@interface</code>,所有的注解自动继承<strong>java.lang.annotation.Annotation接口</strong> ，注解实现部分只能为<strong>注解类型元素</strong>。</p>
<h2 id="2元注解"><a href="#2元注解" class="headerlink" title="2元注解"></a>2元注解</h2><p>​     元注解是专门用于修饰注解的注解（注解注解的注解…..），在声明注解时使用。下面是一些常用的元注解</p>
<h3 id="2-1-Target"><a href="#2-1-Target" class="headerlink" title="2.1 @Target"></a>2.1 @Target</h3><p>​    用来限定此注解可以使用的位置，它使用一个枚举类型ElementType存放不同的常量对象指定不同权限，具体如下。</p>
<table>
<thead>
<tr>
<th>ElemntType.</th>
<th>使用位置</th>
</tr>
</thead>
<tbody><tr>
<td>TYPE</td>
<td>类，接口（包括注解类型）或枚举的声明</td>
</tr>
<tr>
<td>FIELD</td>
<td>属性的声明</td>
</tr>
<tr>
<td>METHOD</td>
<td>方法的声明</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>方法形式参数声明</td>
</tr>
<tr>
<td>CONSTRUCTOR</td>
<td>构造方法的声明</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>局部变量声明</td>
</tr>
<tr>
<td>ANNOTATION_TYPE</td>
<td>注解类型声明</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>包的声明</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Retention"><a href="#2-2-Retention" class="headerlink" title="2.2 @Retention"></a>2.2 @Retention</h3><p>​    用来标记此注解的声明周期，它使用一个枚举类型RetentionPolicy存放不同的常量对象指定不同权限，具体如下。</p>
<table>
<thead>
<tr>
<th>RetentionPolicy.</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>编译前</td>
</tr>
<tr>
<td>CLASS</td>
<td>运行前</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>运行时</td>
</tr>
</tbody></table>
<p><strong>不同生命周期的效果：</strong></p>
<ul>
<li><p>编译前（RetentionPolicy.SOURCE），只存在于.Java文件当中，编译时会被编译器忽略，从而导致此注解不会存在于.class文件当中。实际效果与注释一致。</p>
</li>
<li><p>运行前（RetentionPolicy.CLASS），可以编译到.class文件当中，故编译器编译时可以根据注解信息做出相应操作，但在运行时会被JVM所忽略。</p>
</li>
<li><p>运行时（RetentionPolicy.RUNTIME），可以在运行时通过反射得到注解信息从而进行相应的判断和操作，是自定义注解所使用最多的权限。</p>
<p><strong><em>若自定义注解未指定@Retention则默认为RetentionPolicy.CLASS</em></strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Documented"><a href="#2-3-Documented" class="headerlink" title="2.3 @Documented"></a>2.3 @Documented</h3><p>​    用来标记此注解的是否能被JavaDoc生成到API当中。</p>
<p><strong>示例：</strong></p>
<p>声明一个带有@Documented的CherryAnnotation注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个不带有@Documented的CherryAnnotation2注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个测试类，同时使用上面两个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CherryAnnotation</span></span><br><span class="line"><span class="meta">@CherryAnnotation2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDocumented</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javadoc导出，结果类中只显示了CherryAnnotation</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/Documented%E7%A4%BA%E4%BE%8B.png" alt="Documented示例"></p>
<h3 id="2-4-Inherited"><a href="#2-4-Inherited" class="headerlink" title="2.4 @Inherited"></a>2.4 @Inherited</h3><p>​    用来标记此注解的是否能被子类继承。</p>
<p><strong>验证：</strong></p>
<p>在1.2.2CherryAnnotation注解基础上增加@Inherited</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation的生命周期为运行时。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@CherryAnnotation是可以被使用者的子类继承的</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造一下测试类,这里涉及到反射的知识，简单来说就是尝试获取子类中的CherryAnnotation（简单使用，代码不规范。不理解的可以先跳过，等到泛型和反射的知识就能理解了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CherryAnnotation</span><br><span class="line">public class TestDocumented &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class cla &#x3D; TestDocumentedSon.class;</span><br><span class="line">        CherryAnnotation ca &#x3D;(CherryAnnotation)cla.getAnnotation(CherryAnnotation.class);</span><br><span class="line">        System.out.println(ca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestDocumentedSon extends TestDocumented &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码运行结果：</strong></p>
<p>成功获取到CherryAnnotation，说明子类继承了父类的@CherryAnnotation</p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E4%BD%BF%E7%94%A8Inherited.png" alt="使用Inherited"></p>
<p><strong>若没有使用@Inherited则不会被使用者的子类所继承，运行结果为null</strong></p>
<p><img src="/image/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/%E6%9C%AA%E4%BD%BF%E7%94%A8Inherited.png" alt="未使用Inherited"></p>
<h2 id="3-注解类型元素"><a href="#3-注解类型元素" class="headerlink" title="3.注解类型元素"></a>3.注解类型元素</h2><p>​    注解元素类型是注解特有的一种语法，作用是供读取阶段根据元素的值进行不同操作。由于格式与抽象方法的定义一致，所以有人把注解类型元素叫做注解的抽象方法。又由于调用时需要类似赋值的操作，所以也有的叫做注解的变量/参数。</p>
<h3 id="3-1-注解类型元素的格式"><a href="#3-1-注解类型元素的格式" class="headerlink" title="3.1 注解类型元素的格式"></a>3.1 注解类型元素的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@元注解</span></span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    修饰符 元素类型 元素名();<span class="comment">//与抽象方法的格式一致</span></span><br><span class="line">        <span class="comment">//可以定义多个注解类型元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有几点需要注意：</strong></p>
<ul>
<li>修饰符必须为<strong>public</strong>，若省略则<strong>默认为public</strong>。</li>
<li>元素的类型只能是 <strong>基本数据类型</strong>、<strong>String</strong>、<strong>Class</strong>、<strong>枚举类型</strong>、<strong>注解类型</strong>（体现了注解的嵌套效果）以及<strong>上述类型的一位数组。</strong></li>
<li>不能在括号中定义任何参数，仅仅只是一个特殊的语法；</li>
</ul>
<h3 id="3-2-传入方式"><a href="#3-2-传入方式" class="headerlink" title="3.2 传入方式"></a>3.2 传入方式</h3><p>​    若定义了注解类型元素，则需要在使用这个注解时传入相应的值,格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@注解名(元素名1 = 传入的值,元素名2 = 传入的值)</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=1)</span><span class="comment">//使用3.1中的CherryAnnotation</span></span><br></pre></td></tr></table></figure>

<p><strong>有几点需要注意：</strong></p>
<ul>
<li>若注解中只定义了一个元素，可以将其命名为<strong>value</strong>，在使用注解时可以省略**元素名 =**，例如元注解中的@Target、@Retention。</li>
<li>如果没有默认值，使用注解时必须给该类型元素赋值</li>
<li>默认值的定义方法为在定义元素的后面加上<code>default</code>和（空格）默认值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改造一下CherryAnnotation</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span><span class="keyword">default</span> 1</span>;<span class="comment">//将元素a的默认值设为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;)</span><span class="comment">//使用时不传入a值则默认为1</span></span><br><span class="line"><span class="meta">@CherryAnnotation(str = &quot;abc&quot;,a=2)</span><span class="comment">//若有传入值则为传入值。</span></span><br></pre></td></tr></table></figure>

<h2 id="4注解的读取"><a href="#4注解的读取" class="headerlink" title="4注解的读取"></a>4注解的读取</h2><p><strong>由于涉及反射内容，整理完Java基础之反射后再更新</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown常用语法</title>
    <url>/2020/08/05/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h1><p>​    工欲善其事必先利其器，markdown作为最适合程序员的文本编辑格式，是写技术博客不可或缺的一环，花了一天时间学习了相关的语法，总结分享作为新博客的第一篇文章。</p>
<a id="more"></a>

<h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><h3 id="0-标题"><a href="#0-标题" class="headerlink" title="0.标题"></a>0.标题</h3><p>​    标题格式：<strong># + 空格 + 标题内容</strong>，几个’#就代表几级标题。</p>
<h3 id="1-字体"><a href="#1-字体" class="headerlink" title="1.字体"></a>1.字体</h3><p>​        字体格式：<strong>*文本内容* 或  _文本内容_</strong> ，一个符号为<em>斜体文本</em>，两个符号为<strong>粗体文本</strong>，三个符号为**<em>粗斜体文本**</em>。</p>
<table>
<thead>
<tr>
<th align="center">输入内容</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*斜体文本* 或  _斜体文本_</td>
<td align="center"><em>斜体文本</em></td>
</tr>
<tr>
<td align="center">**粗体文本** 或 __粗体文本__</td>
<td align="center"><strong>粗体文本</strong></td>
</tr>
<tr>
<td align="center">***粗斜体文本*** 或 ___粗斜体文本___</td>
<td align="center"><strong><em>粗斜体文本</em></strong></td>
</tr>
</tbody></table>
<h3 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2.删除线"></a>2.删除线</h3><p>​        删除线格式：<strong>~~删除线文本~~</strong></p>
<table>
<thead>
<tr>
<th align="center">输入内容</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通文本</td>
<td align="center">普通文本</td>
</tr>
<tr>
<td align="center">~~删除线文本~~</td>
<td align="center"><del>删除线文本</del></td>
</tr>
</tbody></table>
<h3 id="3-下划线"><a href="#3-下划线" class="headerlink" title="3.下划线"></a>3.下划线</h3><p>​        下划线格式：<strong>&lt;u&gt;带下划线的文本&lt;/u&gt;</strong></p>
<table>
<thead>
<tr>
<th align="center">输入内容</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通文本</td>
<td align="center">普通文本</td>
</tr>
<tr>
<td align="center">&lt;u&gt;带下划线的文本&lt;/u&gt;</td>
<td align="center"><u>带下划线的文本</u></td>
</tr>
</tbody></table>
<h3 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h3><p>​    <strong>使用脚注</strong>：文本内容[^脚注名称]，<strong>解释脚注：</strong>[^脚注名称]:脚注内容。</p>
<p>​    <strong>效果</strong>：文本内容<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^脚注</a></p>
<h3 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h3><p>​    使用三个或以上 * 或 - 来使用下划线，可以在符号中加空格（可能会在编写软件中识别为其他符号，<strong>不建议使用</strong>），且本行中不可有其他内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">几种分割线示意：</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>分割线效果：</p>
<hr>
<p><strong>错误示范</strong>：***其他内容（未出现分割线效果）</p>
<h2 id="列表与区块"><a href="#列表与区块" class="headerlink" title="列表与区块"></a>列表与区块</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    无序列表格式：<strong>* 或 + 或 - 加上一个空格后面再加上内容</strong>，三个符号效果相同。</p>
<p><strong>输入</strong>：</p>
<p>​    * 无序第一列</p>
<p>​    + 无序第二列</p>
<p>​    -  无序第三列</p>
<p><strong>效果</strong>：</p>
<pre><code>    * 无序第一列</code></pre>
<ul>
<li>无序第二列</li>
</ul>
<ul>
<li>无序第三列</li>
</ul>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​    有序列表格式：<strong>数字+ . + 空格 + 内容</strong>，即将无序列表的符号替换为数字加点的格式（例如1.）。</p>
<p><strong>输入</strong>：</p>
<p>​    1. 有序第一列</p>
<p>​    2. 有序第二列</p>
<p>​    3. 有序第三列</p>
<p><strong>效果</strong>:</p>
<ol>
<li>有序第一列</li>
<li>有序第二列</li>
<li>有序第三列</li>
</ol>
<h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​    在语法中为在<strong>子列表前添加四个空格</strong>，不过一般都在编写软件上编写<strong>更推荐使用TAB（缩进）与SHIFT+TAB（反缩进）</strong></p>
<p>​    <strong>输入</strong>：</p>
<p>​    1. 第一项：</p>
<p>​        * 第一项嵌套的第一个元素</p>
<p>​        * 第一项嵌套的第二个元素</p>
<p>​    2. 第二项：</p>
<p>​        * 第二项嵌套的第一个元素</p>
<p>​        * 第二项嵌套的第二个元素</p>
<p><strong>效果</strong>:</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<pre><code>* 第二项嵌套的第一个元素
   * 第二项嵌套的第二个元素</code></pre>
</li>
</ol>
<h3 id="4-区块"><a href="#4-区块" class="headerlink" title="4.区块"></a>4.区块</h3><p>​    区块格式：<strong>在每行前加上 &gt; 然后紧跟一个空格。</strong></p>
<p><strong>输入：</strong></p>
<p>&gt; 区块引用第一行</p>
<p>&gt; 区块引用第二行</p>
<p><strong>效果：</strong></p>
<blockquote>
<p>区块引用第一行</p>
<p>区块引用第二行</p>
</blockquote>
<h3 id="5-区块嵌套"><a href="#5-区块嵌套" class="headerlink" title="5.区块嵌套"></a>5.区块嵌套</h3><p>​    区块嵌套格式：<strong>每有一个 &gt; 号就表示一层嵌套</strong></p>
<p><strong>输入：</strong></p>
<p>&gt; 最外层</p>
<p>&gt;&gt; 第一层嵌套</p>
<p>&gt;&gt;&gt; 第二层嵌套</p>
<p>**效果: **</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-代码片段"><a href="#1-代码片段" class="headerlink" title="1.代码片段"></a>1.代码片段</h3><p>​    代码片段格式：**` 代码内容 ` **(反引号)</p>
<p>​    <strong>输入：</strong> ` int a ;`         <strong>效果：</strong> <code>int a;</code></p>
<h3 id="2-代码区块"><a href="#2-代码区块" class="headerlink" title="2.代码区块"></a>2.代码区块</h3><p>​    格式：用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<p><strong>输入：</strong></p>
<p>​    ``` java</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(“Hello World”);<br>    }<br>}</p>
<p>​    ```</p>
<p><strong>效果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="1-直接显示链接"><a href="#1-直接显示链接" class="headerlink" title="1.直接显示链接"></a>1.直接显示链接</h3><p>​    语法格式: <strong>&lt; 链接 &gt; **    **效果:</strong> <a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<h3 id="2-用名称替代链接"><a href="#2-用名称替代链接" class="headerlink" title="2.用名称替代链接"></a>2.用名称替代链接</h3><p>​    语法格式：**[链接名称](链接地址)  **效果：这是我的<a href="https://ykailh.github.io/">博客</a></p>
<h3 id="3-用名称和变量替代链接"><a href="#3-用名称和变量替代链接" class="headerlink" title="3.用名称和变量替代链接"></a>3.用名称和变量替代链接</h3><p>​    语法格式：<strong>[链接名称][变量名称]，[变量名称]</strong>: 链接。变量定义类似于脚注，效果与用名称替代类似，但方便多次使用。</p>
<p>效果：这是一个<a href="https://www.baidu.com/">百度链接</a>，再次使用<a href="https://www.baidu.com/">百度链接</a>。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    <strong>用 | 来分隔单元格，- 来分隔表头。</strong></p>
<p><strong>输入：</strong></p>
<p>| 表头 | 表头 |</p>
<p>|  —-  |  —-  |</p>
<p>| 单元格 | 单元格 |</p>
<p>| 单元格 | 单元格 |</p>
<p><strong>效果：</strong></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p><strong>默认为左对齐</strong></p>
<hr>
<p>将分隔符替换为<strong>-: , :-  , :-:</strong> 分别表示右对齐，左对齐，居中对齐。</p>
<p><strong>输入：</strong></p>
<p>| 左对齐 | 右对齐 | 居中对齐 |</p>
<p>|  :—-  |  —-:  | :—-: |</p>
<p>| 单元格 | 单元格 | 单元格 |</p>
<p>| 单元格 | 单元格 | 单元格 |</p>
<p><strong>效果</strong>：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>​    图片插入格式：![图片名](图片相对路径/绝对路径/图片链接)；</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>​    编写md文件时建议使用专用的编辑器，一般都支持自动补全和实时预览，可以提高编写的效率。博主正在用的也是许多人推荐的Typora,也推荐给大家。<a href="https://www.typora.io/">Typora官网</a></p>
<hr>
]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Typora</tag>
        <tag>常用软件</tag>
      </tags>
  </entry>
</search>
